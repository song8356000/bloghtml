---
title: WIN32汇编定时器的使用
date: 2016-04-06 21:33:56
tags: CSDN迁移
---
 版权声明：需要转载的请注明出处 https://blog.csdn.net/qq_22642239/article/details/51078323   
   **今天学习了定时器的用法，小有感悟，首先是资源脚本中遇到的问题，先上资源脚本文件：**

 


```
// Generated by ResEdit 1.6.6
// Copyright (C) 2006-2015
// http://www.resedit.net
#include <windows.h>
#include <commctrl.h>
#include <richedit.h>
#define IDI_ICON1                               1
#define IDI_ICON2                               2
#define IDD_DIALOG1                             103
#define IDC_SETICON                             100
#define IDC_COUNT                               102
//
// Dialog resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDD_DIALOG1 DIALOG 0, 0, 186, 95
STYLE DS_CENTER | DS_MODALFRAME | DS_SETFONT | WS_CAPTION | WS_VISIBLE | WS_POPUP | WS_SYSMENU
CAPTION "定时器例子"
FONT 9, "宋体"
{
    LTEXT           "计数：", 101, 75, 30, 25, 9, SS_LEFT, WS_EX_LEFT
    LTEXT           "", 102, 119, 28, 17, 26, SS_LEFT, WS_EX_LEFT
    icon         "",100,23, 22, 38, 33, WS_EX_LEFT               //   就是这一句
}
//
// Icon resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDI_ICON1          ICON           "icon4.ico"

LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDI_ICON2          ICON           "icon8.ico"

```
  
  
****

 **和往常一样，使用ResEdit编辑器编辑资源文件然后在RadASM上面编译，今天遇到一个新的问题，就是关于窗口控件的两种定义方式，以前我以为无论用哪一种都可以，上面文件中作注释的地方，今天编写的时候我刚开始使用的是: control '''' ,100,static,23,22,38,33,WS_EX_LEFT 这样的的定义方式，但是这样程序虽然可以运行，但是图标框里面要求250ms变换图标的操作没有完成， 文本框，图标框，位图框等都应该属于Static**

 **类，但是写成上面的控件格式图标框内不会显示图片，只有定义成上边脚本文件中的格式才可以，书上有一句话说的是:使用control语句定义的时候可能不是很直观,使用上边脚本中的定义方式，“控件名称”由RC.exe解释成类名，这样比较准确，因此我感觉以后还是使用上边脚本文件中那种定义方式比较靠谱。**

 **  
**

 下面实现代码：

 


```
.386
                .model flat,stdcall
                option casemap:none
;-------------------------------------------------------------------
;include  文件定义
;-------------------------------------------------------------------
include         windows.inc
include         user32.inc
includelib      user32.lib
include         kernel32.inc
includelib      kernel32.lib
;-------------------------------------------------------------------
;等值定义
;-------------------------------------------------------------------
IDI_ICON1       equ       1
IDI_ICON2       equ       2
IDD_DIALOG1     equ       103
IDC_SETICON     equ       100
IDC_COUNT       equ       102
ID_TIMER1       equ       1
ID_TIMER2       equ       2
;-------------------------------------------------------------------
;数据段
;-------------------------------------------------------------------
                .data?
hInstance       dd        ?
hWinMain        dd        ?
dwCount         dd        ?
idTimer         dd        ?
;-------------------------------------------------------------------
;代码段 
;-------------------------------------------------------------------
                .code
;-------------------------------------------------------------------
;定时器过程
;-------------------------------------------------------------------
_ProcTimer      proc      _hwnd,uMsg,_idEvent,_dwTime

       pushad
       invoke    GetDlgItemInt,hWinMain,IDC_COUNT,NULL,FALSE
       inc       eax
       invoke    SetDlgItemInt,hWinMain,IDC_COUNT,eax,FALSE
       popad
       ret


_ProcTimer endp
;-------------------------------------------------------------------
;窗口过程
;-------------------------------------------------------------------
_ProcDlgMain    proc      uses ebx edi esi,hWnd,uMsg,wParam,lParam

       mov       eax,uMsg
       .if       eax ==  WM_TIMER
                 mov     eax,wParam
                .if      eax ==  ID_TIMER1
                 inc     dwCount                                 ；此处很有意思
                 mov     eax,dwCount
                 and     eax,1
                 inc     eax
                 invoke  LoadIcon,hInstance,eax
                 invoke  SendDlgItemMessage,hWnd,IDC_SETICON,STM_SETIMAGE,IMAGE_ICON,eax
               .elseif   eax ==  ID_TIMER2
                 invoke  MessageBeep,-1
               .endif
       .elseif eax ==  WM_INITDIALOG
        push    hWnd                                             ；注意此处的储存变量的方式
        pop     hWinMain
        invoke  SetTimer,hWnd,ID_TIMER1,250,NULL
        invoke  SetTimer,hWnd,ID_TIMER2,2000,NULL
        invoke  SetTimer,NULL,NULL,1000,addr _ProcTimer
        mov     idTimer,eax
;-------------------------------------------------------------------
                .elseif eax ==  WM_CLOSE
                invoke  KillTimer,hWnd,ID_TIMER1
                invoke  KillTimer,hWnd,ID_TIMER2
                invoke  KillTimer,hWnd,idTimer
                invoke  EndDialog,hWnd,NULL
;-------------------------------------------------------------------
                .else   
                mov eax,FALSE
                ret
                .endif
                mov     eax,TRUE
                ret


_ProcDlgMain endp
;-------------------------------------------------------------------
start:
                invoke GetModuleHandle,NULL
                mov    hInstance,eax
                invoke DialogBoxParam,hInstance,IDD_DIALOG1,NULL,offset _ProcDlgMain,NULL
                invoke ExitProcess,NULL
;-------------------------------------------------------------------
                end    start
```
  
  


 在程序代码上做注释的地方 那种变换eax的值的方式来载入不同的图标的方式很值得学习。

 还有 利用栈储存数据的方式很值得借鉴。

 

 今天又接触到了一种windows的消息类型WM_TIMER

 

 


```
API函数：
SetTimer()
功能：
一种API函数，位于user32.dll中。你想每隔一段时间执行一件事的的时候，你可以使用它。 使用定时器的方法比较简单，通常告诉Windows一个时间间隔，然后Windows以此时间间隔周期性触发程序。通常有两种方法来实现:发送WM_TIMER消息和调用应用程序定义的回调函数。不需要指定定时器时，可以调用对应的KillTimer函数销毁指定的时钟。
原型参数：
UINT_PTR SetTimer(

HWND hWnd, // 窗口句柄

UINT_PTR nIDEvent, // 定时器ID，多个定时器时，可以通过该ID判断是哪个定时器

UINT nElapse, // 时间间隔,单位为毫秒

TIMERPROC lpTimerFunc // 回调函数

);

返回值：

类型:UINT_PTR

如果函数成功,hWnd参数为0,则返回新建立的时钟编号,可以把这个时钟编号传递给KillTimer来销毁时钟.

如果函数成功,hWnd参数为非0,则返回一个非零的整数,可以把这个非零的整数传递给KillTimer来销毁时钟.

如果函数失败,返回值是零.


KillTimer()

功能：

该函数移除先前用SetTimer设置的定时器。在定时器使用完毕后移除定时器时使用。

原型：

KillTimer(

HWND hWnd

UINT_PTR nIDEvent

)

参数：

hWnd:与定时器相关联的窗口句柄

nIDEvent: 传递给SetTimer的定时器ID值。

返回值：

如果函数成功,返回一个非0值,

如果失败,返回值为0


MessageBeep（）

功能：

用来播放一个波形声音。

原型：

BOOL MessageBeep(

UINT uType //根据不同的类型来定

);

参数;
uType

Specifies the sound type, as identified by an entry in the [sounds] section of the registry. It is one of the following values.

Value Description （数值描述）：

0xFFFFFFFF SystemDefault （从机器的扬声器中发出蜂鸣声）

MB_ICONASTERISK SystemAsterisk （播放由SystemAsterisk定义的声音）

MB_ICONEXCLAMATION SystemExclamation （播放由SystemExclamation定义的声音）

MB_ICONHAND SystemHand （播放由SystemHand定义的声音）

MB_ICONQUESTION SystemQuestion （播放由SystemQuestion定义的声音）

MB_OK SystemDefault （播放由SystemDefault定义的声音）

返回值：

.Nonzero indicates success. (非零表示成功)

2.Zero indicates failure. （零表示不成功）

结束。

```
  
  
  


   
 