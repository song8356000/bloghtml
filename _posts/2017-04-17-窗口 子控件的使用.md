---
title: 窗口 子控件的使用
date: 2016-04-01 12:35:41
tags: CSDN迁移
---
 版权声明：需要转载的请注明出处 https://blog.csdn.net/qq_22642239/article/details/51034136   
   **在对话框中使用控件(control)，首先应该熟悉控件的两种定义方式，虽然有时候用不到自己去编写资源脚本，但是控件在定义的时候有许多参数需要根据实际情况附加，我在编写资源脚本的时候，用ResEdit软件编写的时候，当我定义好一些类型属性，去预览代码的时候，好多属性参数和用其他工具编写的属性参数有的是不一样的，当你把在ResEdit上编写的资源脚本代码粘贴到RadASM里面的工程中的资源文件里的时候，总会出现一些错误，这两个软件的有些内容好像有些许的差距，在用ResEdit编写的时候有一些参数在RadASM里面识别不了，比如**

 **WC_STATIC，在RadASM中直接写成satic 才可以，因为已经包含了头文件#include <windows.h>  
 #include <commctrl.h>  
 #include <richedit.h>**

 **等 所以应该不会是等值定义，关于空间的定义 ：**

 **1：control 文本，ID，类，风格，x,y,宽度，高度，[扩展风格]**

 **2：控件名称 [文本] ID，x,y,宽度，高度， 风格，扩展风格**

 **关于上面提到的static 其实就是一个类名，但是在ResEdit中编译好的资源脚本的代码中static这个类的位置就是有WC_STATIC这个家伙代替的，估计这是软件内部的定义，知道就可以了，以后出现问题的时候知道怎么修改就行了。**

 **下面开始编写一个资源脚本文件，同样是在ResEdit中编写出来的，再拿到RadASM上编译资源脚本（其中的一些参数出现了以上提到的一些错误，都已经在代码处修改了可以再RadASM上边编译成功），资源脚本文件代码如下：**

 

 
```
// Generated by ResEdit 1.6.6
// Copyright (C) 2006-2015
// http://www.resedit.net


#include <windows.h>
#include <commctrl.h>
#include <richedit.h>
#include "resource.h"
//
// Bitmap resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDB_BITMAP1        BITMAP         "bitmap7.bmp"




LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDB_BITMAP2        BITMAP         "bitmap8.bmp"






//
// Dialog resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDD_DIALOG1 DIALOG 0, 0, 319, 148
STYLE DS_3DLOOK | DS_MODALFRAME | WS_CAPTION | WS_VISIBLE | WS_POPUP | WS_SYSMENU
CAPTION "对话框子窗口控件示例"
FONT 8, "Ms Shell Dlg"
{
    CONTROL         "", 23, STATIC, SS_ETCHEDHORZ, 4294967294, 130, 312, 1, WS_EX_LEFT
    LTEXT           "0", 25, 181, 135, 9, 9, WS_EX_LEFT
    CONTROL         "IDB_BITMAP1", 10, STATIC, WS_BORDER | SS_BITMAP, 2, 7, 41, 115, WS_EX_LEFT
    AUTORADIOBUTTON "可变边框(Thick Frame)", 17, 63, 98, 91, 8, 0, WS_EX_LEFT
    SCROLLBAR       24, 3, 134, 166, 12, 
    AUTORADIOBUTTON "模态边框(Modal Frame)", 16, 63, 82, 93, 8, 0, WS_EX_LEFT
    CONTROL         "", 15, STATIC, SS_ETCHEDHORZ, 58, 72, 87, 1, WS_EX_LEFT
    AUTOCHECKBOX    "显示图片", 13, 65, 42, 48, 8, 0, WS_EX_LEFT
    AUTOCHECKBOX    "允许更换图片", 14, 65, 54, 64, 8, 0, WS_EX_LEFT
    GROUPBOX        "选项", 11, 51, 8, 106, 115, 0, WS_EX_STATICEDGE
    AUTOCHECKBOX    "总在最前面", 12, 65, 30, 56, 8, 0, WS_EX_LEFT
    LTEXT           "自定义文字", 20, 165, 44, 41, 9, SS_LEFT, WS_EX_LEFT
    EDITTEXT        21, 168, 57, 123, 13, ES_AUTOHSCROLL, WS_EX_STATICEDGE
    GROUPBOX        "标题栏文字", 18, 162, 5, 149, 119, 0, WS_EX_LEFT
    COMBOBOX        19, 167, 26, 124, 100, CBS_DROPDOWNLIST | WS_TABSTOP
    LTEXT           "请在此选择显示在标题栏上的文字，或者选择“自定义”后自行输入", 22, 168, 91, 123, 30,WS_BORDER
    PUSHBUTTON      "退出(&X)", IDCANCEL, 273, 134, 34, 14, 0, WS_EX_LEFT
    DEFPUSHBUTTON   "更换图片(&C)", IDOK, 212, 134, 50, 14, 0, WS_EX_LEFT
}

//
// Icon resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDI_ICON1          ICON           "icon1.ico"

```
  
  


 **关于这句#include "resource.h" 其实也可以不要，你可以打开ResEdit程序安装目录下，在创建这个工程的文件夹里面找到这个头文件，点开以后发现里面就是一些宏定义，把一些数字等值定义为一些比较容易理解记忆的字符而已，其实可以把这些宏定义直接复制到资源文件代码中，这样有一点好处（我自己感觉），就是当你用其他资源编译工具编译这些资源代码的时候，你不用再去把#include "resource.h" 这个 文件从这里来回的拖来拖去，就可以直接编译资源脚本了，假如你在使用其他资源编译器编译的时候，没有把这个文件放到创建的相应的工程目录下的时候，在编译的时候肯定会出现一些错误（一些语句未定义），这个当时我也纠结了很久才发现，哎！毕竟是小白 一步一步的走才可以。**

 **  
**

 **  
**

 **下面来编写代码载入编写好的资源文件**

 **在载入控件资源文件的的时候，会出现一些新的消息类型，还有一些新的API函数（这个是绝对的），首先来看一下代码。然后在仔细分析那些新的消息类型，和一些陌生的API函数。这个例子就是罗云斌老师讲解WIN32时候例子，只不过，是我自己稍加改动，我在代码中使用的控件ID是16位的数字，刚开始我以为这样应该会比较简单不用再去麻烦的定义一大堆的等值定义，直接按照资源文件中自己自定义的控件 ID去转化为16进制（WIN32中16进制的数字大小写没有区别都可以）的数字直接写到那些API函数的参数中去，这个想法很幼稚，当我编写好资源脚本文件并且自己定义了控件的ID的时候，再去编写实现代码在写那些API函数的参数的时候，还要去资源脚本代码中一个一个 的找数字，然后再一个一个的转换为16进制的数据作为API函数的参数，真是崩溃了，找的真是晕头转向，这时候才知道等值定义是多么好的一个举措。下面上功能代码。**

 **代码：**

 ** **

 
```
.386
                .model flat,  stdcall
                option casemap :none
;*********************************************************************
;Include 文件定义
;*********************************************************************
include         windows.inc
include         user32.inc 
includelib      user32.lib
include         kernel32.inc
includelib      kernel32.lib
include         gdi32.inc
includelib      gdi32.lib
;*********************************************************************
;equ      等值定义
;*********************************************************************
IDD_DIALOG1     equ        64h
IDI_ICON1       equ        65h
IDB_BITMAP1     equ        6ch
IDB_BITMAP2     equ        6dh
;*********************************************************************
;数据段
;********************************************************************* 
                .data?
hInstance       dd         ?
hBmp1           dd         ?
hBmp2           dd         ?
dwPos           dd         ?
                .const
szText1         db         'Hello,World!',0
szText2         db         '你看到标题栏变了么？',0
szText3         db         '自定义',0
;*********************************************************************
;代码段
;*********************************************************************
                .code
_ProcDlgMain    proc       uses ebx edi esi hWnd,wMsg,wParam,lParam
                LOCAL      @szBuffer[128]:byte
                
                mov        eax,wMsg
        .if     eax  ==    WM_CLOSE
        invoke     EndDialog,hWnd,NULL
        invoke     DeleteObject,hBmp1
        invoke     DeleteObject,hBmp2
        .elseif eax  ==    WM_INITDIALOG
;*********************************************************************
;设置标题栏图标
;*********************************************************************
                invoke     LoadIcon,hInstance,IDI_ICON1
                invoke     SendMessage,hWnd,WM_SETICON,ICON_BIG,eax
;*********************************************************************
;初始化组合框
;*********************************************************************
                invoke     SendDlgItemMessage,hWnd,13h,CB_ADDSTRING,0,addr szText1
                invoke     SendDlgItemMessage,hWnd,13h,CB_ADDSTRING,0,addr szText2
                invoke     SendDlgItemMessage,hWnd,13h,CB_ADDSTRING,0,addr szText3
                invoke     SendDlgItemMessage,hWnd,13h,CB_SETCURSEL,0,0
                invoke     GetDlgItem,hWnd,15h
                invoke     EnableWindow,eax,FALSE
                invoke     LoadBitmap,hInstance,IDB_BITMAP1
                mov        hBmp1,eax
                invoke     LoadBitmap,hInstance,IDB_BITMAP2
                mov        hBmp2,eax
;*********************************************************************
;初始化单选钮和复选框
;*********************************************************************
                invoke    CheckDlgButton,hWnd,0Dh,BST_CHECKED
                invoke    CheckDlgButton,hWnd,0Eh,BST_CHECKED
                invoke    CheckDlgButton,hWnd,11h,BST_CHECKED
;*********************************************************************
;初始化滚动条
;*********************************************************************
                invoke    SendDlgItemMessage,hWnd,18h,SBM_SETRANGE,0,100
        .elseif eax  ==   WM_COMMAND
                mov       eax,wParam
                .if       ax  ==  IDCANCEL
                          invoke EndDialog,hWnd,NULL
                          invoke DeleteObject,hBmp1
                          invoke DeleteObject,hBmp2
;*********************************************************************
;更换图片
;*********************************************************************
                .elseif   ax  ==  IDOK
                 mov     eax,hBmp1
                 xchg    eax,hBmp2
                 mov     hBmp1,eax
                 invoke  SendDlgItemMessage,hWnd,0Ah,STM_SETIMAGE,IMAGE_BITMAP,eax
;*********************************************************************
;设置“总在最前面”
;*********************************************************************
                .elseif   ax  ==  0Ch
                          invoke  IsDlgButtonChecked,hWnd,0Ch
                          .if     eax ==  BST_CHECKED
                                  invoke  SetWindowPos,hWnd,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE or SWP_NOSIZE
                          .else   
                                  invoke  SetWindowPos,hWnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE or SWP_NOSIZE
                          .endif
;*********************************************************************
;演示隐藏和显示图片控件
;*********************************************************************
                .elseif   ax  ==  0Dh
                          invoke  GetDlgItem,hWnd,0Ah
                          mov ebx,eax
                          invoke  IsWindowVisible,ebx
                          .if     eax
                           invoke  ShowWindow,ebx,SW_HIDE
                          .else   
                                  invoke  ShowWindow,ebx,SW_SHOW
                          
                          .endif
;*********************************************************************
;演示允许和灰化“更换图片”按钮
;*********************************************************************
                .elseif   ax  ==  0Eh
                          invoke  IsDlgButtonChecked,hWnd,0eh
                          .if     eax == BST_CHECKED
                                  mov    ebx,TRUE
                          .else   
                           xor    ebx,ebx
                          .endif
                          invoke  GetDlgItem,hWnd,IDOK
                          invoke  EnableWindow,eax,ebx
;*********************************************************************
                .elseif   ax  ==  10h
                          invoke  GetWindowLong,hWnd,GWL_STYLE
                          and     eax,not WS_THICKFRAME
                          invoke  SetWindowLong,hWnd,GWL_STYLE,eax
                .elseif   ax  ==  11h
                          invoke  GetWindowLong,hWnd,GWL_STYLE
                          or  eax,WS_THICKFRAME
                          invoke  SetWindowLong ,hWnd,GWL_STYLE,eax
;*********************************************************************
;演示处理下拉式组合框
;*********************************************************************
                .elseif   ax  ==  13h
                          shr     eax,16
                          .if     ax ==   CBN_SELENDOK
                           invoke  SendDlgItemMessage,hWnd,13h,CB_GETCURSEL,0,0
                           .if     eax == 2
                            invoke GetDlgItem,hWnd,15h
                            invoke EnableWindow,eax,TRUE
                           .else
                            mov    ebx,eax
                            invoke SendDlgItemMessage,hWnd,13h,CB_GETLBTEXT,ebx,addr @szBuffer
                            invoke SetWindowText,hWnd,addr @szBuffer
                            invoke GetDlgItem,hWnd,15h
                            invoke EnableWindow,eax,FALSE
                           .endif
                          .endif
;**********************************************************************
;在文本框中输入文字
;**********************************************************************
                .elseif   ax  == 15h
                          invoke GetDlgItemText,hWnd,15h,addr @szBuffer,sizeof @szBuffer
                          invoke SetWindowText,hWnd,addr @szBuffer
                .endif
;**********************************************************************
;处理滚动条消息
;**********************************************************************
        .elseif eax  ==   WM_HSCROLL
                mov       eax,wParam
                .if       ax  == SB_LINELEFT
                          dec    dwPos
                .elseif   ax  == SB_LINERIGHT
                 inc    dwPos
                .elseif   ax  == SB_PAGELEFT
                          sub    dwPos,10
                .elseif   ax  == SB_PAGERIGHT
                 add    dwPos,10
                .elseif   ax  == SB_THUMBPOSITION || ax == SB_THUMBTRACK
                 mov    eax,wParam
                 shr    eax,16
                 mov    dwPos,eax
                .else
                          mov    eax,TRUE
                          ret
                .endif
                cmp       dwPos,0
                jge       @F
                mov       dwPos,0
                @@:
                cmp       dwPos,100
                jle       @F
                mov       dwPos,100
                @@:
                invoke    SetDlgItemInt,hWnd,19h,dwPos,FALSE
                invoke    SendDlgItemMessage,hWnd,18h,SBM_SETPOS,dwPos,TRUE
;*************************************************************************
        .else   
                mov       eax,FALSE
        ret
        .endif
        mov     eax,TRUE
ret

_ProcDlgMain    endp
;*************************************************************************
start:
                invoke    GetModuleHandle,NULL
                mov       hInstance,eax
                invoke    DialogBoxParam,hInstance,IDD_DIALOG1,NULL,offset _ProcDlgMain,NULL
                invoke    ExitProcess,NULL
;*************************************************************************
                end       start   
```
  
  


 **  
**

 **代码完毕。**

 **看完之后 总感觉有一种似曾相识的感觉，其实就是这样，WIN32的程序框架真的都长得很像，只不过是消息的类型和一些API函数的不同，下面来介绍这么多陌生的API函数以便以后作为参考以及一些新认识汇编命令。**

 **  
**

 **首先是几个在编写的时候感觉较为陌生的命令及语句：**

 **  
**

 **1.shr eax,16**

 **这一句 就是逻辑右移指令，意思是把寄存器eax的32位数据右移16位（其实就是为了获取消息的一个参数wParam高16位的数据）**

 **shl 逻辑左移，其他同理。**

 2.jge @F  
 mov dwPos,0  
 @@:

 意思就是：如果大于等于则跳转，跳转位置就是本条指令后的第一个@@标号处

 jge@B表示 如果大于等于则跳转到本条指令前的第一个@@标号处。

 

 

 **下面分析一下那些陌生的API函数：**

 

 

 
```
DeleteObject()
功能：
该函数删除一个逻辑笔、画笔、字体、位图、区域或者调色板，释放所有与该对象有关的系统资源，在对象被删除之后，指定的句柄也就失效了。
原型：
BOOL DeleteObject(HGDIOBJ hObject)；
参数：
hObject：逻辑笔、画笔、字体、位图、区域或者调色板的句柄
返回值：
成功，返回非零值；如果指定的句柄无效或者它已被选入设备上下文环境，则返回值为零。

SendDlgItemMessage（）
功能：
该函数把一个消息发送给指定的对话框中的控件
原型：
LONG SendDlgItemMessage(

HWND hDlg

int nIDDlgItem,

UINT Msg,

WPARAM wParam,

LPARAM lParam 

);

参数：

hDlg:指定含有控件的对话框句柄。

nIDDigItem:指定接收消息的控件的标识符。

Msg:指定将被发送的消息。

wParam:指定消息特定的其他信息。

lParam:指定消息特定的其他信息。

返回值：

返回值指定消息处理的结果，且依赖于发送的消息



LoadBitmap()

功能：

该函数从模块的可执行文件中加载指定的位图资源。该函数已经被函数LoadImage替代

原型：

HBITMAP LoadBitmap(HINSTANCE hInstance, LPCTSTR lpBitmapName);

参数：


hlnstance:指向模块实例的句柄。该模块的可执行文件包含了要加载的位图。

lpBitmapName:指向字符串(以NULL结束)批指针。该字符串包含了要加载的位图资源名称。另外一种方式就是该参数可以由低位字是资源标识符、高位字为0位形式组成。可以使用宏MAKEINTRESOURCE来创建这个参数值。

返回值：

如果函数执行成功，则返回值是指向指定位图的句柄。如果函数执行失败，那么返回值是NULL。



CheckDlgButton()

功能：

该函数改变按钮控制的选中状态

原型：

BOOL CheckDlgButton（HWNDhDlg，int nlDButton,UINT uCheck）；

参数;


hDlg：指向含有该按钮的对话框的句柄。

nlDButton：标识要修改的按钮。

uCheck：给定该按钮的选中状态。该参数可取下列值，这些值的含义如下：

BST_CHECKED：设置按钮状态为己选中（checked）。

BST_INDETERMINATE：设置按钮状态变灰，表示不确定状态。只有在该按钮具有BS_3STATE或BS_AUTO3STATE样式时才能使用该值。

BST_UNCHECKED：设置按钮为未选中状态（unchecked）。

返回值：
如果函数执行成功，返回值非零；如果函数失败，则返回值为零



IsDlgButtonChecked（）

功能：

该函数可以确定某个按钮控制是否有选中标志，或者三态按钮控制是否为灰色的、选中的、或两者都不是。

原型：

UINT IsDlgButtonChecked（HWND hDlg，Int nlDBUtton）；

参数：


Dlg：指向包含按钮控制的对话框。

nkDButtom：指定按钮控制的整型标识符。

  返回值：

使用BS_AUTOCHECKBOX、BS_AUTORADIOBUTTON、BS_AUTO3STATE、BS_CHECKBOX、BS_RADIOBUTION或BS_3STATE样式创建的按钮的返回值可以是如下值之一：

BST_CHECKED：表示按钮被选中。

BST_INDETERMINATE：表示按钮是灰色的，即为不确定状态（只有具有BS_3STATE或BS_AUTO3STATE样式的按钮才使用该值）。

BST_UNCHECKED：表示该按钮未选中（unckecked）。如果该按钮用其他任何样式，那么返回值为零。


SetWindowPos（）

功能：

调用这个成员函数以改变子窗口、弹出窗口和顶层窗口的大小、位置和Z轴次序。窗口在屏幕上按照它们的Z轴次序排序。在Z轴次序上处于顶端的窗口将程序在所有其它窗口的顶部。子窗口的所有坐标都是客户坐标（相对于副窗口客户区的左上角）。

原型：

BOOL SetWindowPos(HWND hWnd, const CWnd* pWndInsertAfter, int x, int y,int cx, int cy, UINT nFlags);

参数：

hWnd

窗口句柄。

hWndlnsertAfter

在z序中的位于被置位的窗口前的窗口句柄。该参数必须为一个窗口句柄，或下列值之一:

HWND_BOTTOM:将窗口置于Z序的底部。如果参数hWnd标识了一个顶层窗口，则窗口失去顶级位置，并且被置在其他窗口的底部。
HWND_NOTOPMOST:将窗口置于所有非顶层窗口之上(即在所有顶层窗口之后)。如果窗口已经是非顶层窗口则该标志不起作用。
HWND_TOP:将窗口置于Z序的顶部。
HWND_TOPMOST:将窗口置于所有非顶层窗口之上。即使窗口未被激活窗口也将保持顶级位置。
查看该参数的使用方法，请看说明部分。

x

以客户坐标指定窗口新位置的左边界。

Y

以客户坐标指定窗口新位置的顶边界。

cx

以像素指定窗口的新的宽度。

cy

以像素指定窗口的新的高度。

uFlags

窗口尺寸和定位的标志

返回值：

如果函数成功，返回值为非零;如果函数失败，返回值为零。



GetDlgItem（）

功能：

返回窗口中指定参数ID的子元素的句柄，可以通过返回的句柄对窗口内的子元素进行操作

原型：

.Windows SDK

HWND GetDlgItem(

HWND hDlg,

int nIDDlgItem ）;

参数：

hDlg:标识含有控件的对话框.



nIDDlgItem:指定将被检索的控件标识符。

返回值：

如果函数调用成功则返回值为给定控件的窗口句柄。如果函数调用失败，则返回值为NULL，表示为一个无效的对话框句柄或一个不存在的控件。



IsWindowVisible（）

功能：

通过该函数可以获得指定窗口的可视状态，即显示或者隐藏

原型：

BOOL IsWindowVisible(

HWND hWnd

);

参数：

hWnd:被测试窗口的句柄。

返回值;

如果指定的窗口及其父窗口具有WS_VISIBLE风格，返回值为非零;如果指定的窗口及其父窗口不具有WS_VISIBLE风格，返回值为零。由于返回值表明了窗口是否具有Ws_VISIBLE风格，因此，即使该窗口被其他窗口遮盖，函数返回值也为非零。



EnableWindow()

功能：

该函数允许/禁止指定的窗口或控件接受鼠标和键盘的输入，当输入被禁止时，窗口不响应鼠标和按键的输入，输入允许时，窗口接受所有的输入。

原型：

BOOL EnableWindow(HWND hWnd，BOOL bEnable);

参数：


hWnd:被允许/禁止的窗口句柄

bEnable:定义窗口是被允许，还是被禁止。若该参数为TRUE（1），则窗口被允许。若该参数为FALSE（0），则窗口被禁止。

返回值：
在 EnableWindow 成员函数调用之前，指示状态。 如果窗口此前已禁用，则返回值是非零。 返回值是0，则窗口先前启用或错误。



SetClassLong（）

功能：

该函数替换额外的类存储空间中指定偏移量处的32位长整型值，或替换指定窗口所属类的WNDCLASSEX结构(应该是替换这个结构体中值，没有把结构体给换了吧)。

原型：

DWORD SetClassLong(HWND hWnd，int nlndex，LONG dwNewLong)

参数;

hWnd:窗口句柄及间接给出的窗口所属的类。

nlndex:指定将被替换的32位值。在额外类存储空间中设置32位值，应指定一个大于或等于0的偏移量。

有效值的范围从0到额外类的存储空间的字节数一4;例如，若指定了12个字节或多于12个字节的额外类存储空间，则索引值为8时，对应的是第三个32位整数值。要设置WNDCLASSEX结构中的任何值，指定下面索引之一:

GCL_CBCLSEXTRA:设置与类相关的尺寸的字节大小。设定该值不改变己分配的额外字节数。

GCL_CBWNDEXTRA:设置与类中的每一个窗口相关的尺寸的字节大小。设定该值不改变已分配额外字节数。查看如何进入该内存，参看SetWindowLOng。

GCL_HBRBACKGROUND:替换与类有关的背景刷子的句柄。

GCL_HCURSOR:替换与类有关的光标的句柄。GCL_HICON:替换与类有关的图标的句柄。

GCL_HMODULE:替换注册类的模块的句柄。GCL_STYLE:替换窗口类的风格位。

GCL_MENUNAME :替换菜单名字符串的地址。该字符串标识与类有关的菜单资源。

GCL_WNDPROC :替换与窗口类有关的窗口过程的地址。

dwNewLong:指定的替换值。

返回值：

如果函数成功，返回值是原来类结构中32位整数;如果未事先设定，返回值为0。如果函数失败，返回值为0。



GetWindowLong（）

功能：

该函数获得指定窗口的有关信息，函数也获得在额外窗口内存中指定偏移位地址的32位度整型值。

原型：

LONGGetWindowLong(HWND hWnd,int nlndex);

参数：

hWnd:

目标窗口的句柄。

它可以是窗口句柄及间接给出的窗口所属的窗口类。

nlndex:

需要获得的相关信息的类型。

指定要获得值的大于等于0的值的偏移量。有效值的范围从0到额外窗口内存空间的字节数一4例如，若指定了12位或多于12位的额外类存储空间，则应设为第三个32位整数的索引位8。要获得任意其他值，指定下列值之一:

值	意义
GWL_EXSTYLE
(-20)
获得扩展窗口风格。
GWL_HINSTANCE(-6)	获得应用实例的句柄。
GWL_HWNDPARENT
(-8)
如果父窗口存在，获得父窗口句柄。
GWL_ID
(-12)
获得窗口标识。
GWL_STYLE
(-16)
获得窗口风格。
GWL_USERDATA
(-21)
获得与窗口有关的32位值。每一个窗口均有一个由创建该窗口的应用程序使用的32位值。
GWL_WNDPROC
(-4)
获得窗口过程的地址，或代表窗口过程的地址的句柄。必须使用CallWindowProc函数调用窗口过程。
hWnd参数为对话框句柄时，还可用下列值:

值	意义
DWL_DLGPROC
(4)
获得对话框过程的地址，或一个代表对话框过程的地址的句柄。必须使用函数CallWindowProc来调用对话框过程。
DWL_MSGRESULT(0)	获得在对话框过程中一个消息处理的返回值。
DWL_USER
(8)
获得应用程序私有的额外信息，例如一个句柄或指针。
返回值：
如果函数成功，返回值是所需的32位值;如果函数失败，返回值是0。

SetWindowLong（）

功能：

该函数用来改变指定窗口的属性.函数也将指定的一个32位值设置在窗口的额外存储空间的指定偏移位置。

原型：

BOOL SetWindowLong（hWnd,nindex,dwNewLong）

参数：

hWnd：窗口句柄及间接给出的窗口所属的类。

nindex：


指定将设定的大于等于0的偏移值。有效值的范围从0到额外类的存储空间的字节数减4:例如若指定了12或多于12个字节的额外窗口存储空间，则应设索引位8来访问第三个4字节，同样设置0访问第一个4字节，4访问第二个4字节。要设置其他任何值，可以指定下面值之一:

常量
常量值	
意义
GWL_EXSTYLE
-20	
设定一个新的扩展风格。
GWL_HINSTANCE	-6	设置一个新的应用程序实例句柄。
GWL_ID
-12	
设置一个新的窗口标识符。
GWL_STYLE
-16	
设定一个新的窗口风格。
GWL_USERDATA
-21	
设置与窗口有关的32位值。每个窗口均有一个由创建该窗口的应用程序使用的32位值。
GWL_WNDPROC
-4	
为窗口过程设定一个新的地址。
GWL_HWNDPARENT	-8	改变子窗口的父窗口,应使用SetParent函数。
当hWnd参数标识了一个对话框时，也可使用下列值:

常量
常量值	
意义
DWL_DLGPROC
DWLP_MSGRESULT + sizeof(LRESULT) (值:4)	
设置对话框过程的新地址。
DWL_MSGRESULT	0	设置在对话框过程中处理的消息的返回值。
DWL_USER
DWLP_DLGPROC + sizeof(DLGPROC) (值:8)	
设置的应用程序私有的新的额外信息，例如一个句柄或指针。
dwNewLong：

指定的替换值。

dwNewLong中可以使用以下一些列表控件的专用风格:

LVS_ICON LVS_SMALLICON LVS_LIST LVS_REPORT

这四种风格决定控件的外观，同时只可以选择其中一种，分别对应:

大图标显示，小图标显示，列表显示，详细报表显示

LVS_EDITLABELS 结点的显示字符可以被编辑，对于报表风格来讲可编辑的只为第一列。

LVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点

LVS_SINGLESEL 同时只能选中列表中一项

返回值:

如果函数成功，返回值是指定的32位整数的原来的值。如果函数失败，返回值为0



SetWindowText()

功能：

如果指定窗口是一个控件，则改变控件的文本内容。然而，SetWindowText函数不改变在其他应用程序中的控件的文本内容。

原型:

BOOLSetWindowText(

HWNDhwnd,

LPCTSTRlpString

);


参数：

hWnd

要改变文本内容的窗口或控件的句柄。

lpString

指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。

返回值：
如果函数成功，返回值为非零;如果函数失败，返回值为零。



SetDlgItemInt（）

功能：

该函数将uValue的值设为对话框控件的文本。

原型：

BOOL SetDlgItemInt(HWND hDlg,int nIDDlgItem,UINT uValue,BOOL bSigned);.

参数：

hDlg：指向对话框窗口的句柄。

nIDDlgItem：要改变其文本的控件ID。

uValue：指向要设置的值。

bSigned：指定uValue是否为一个有符号的值



GetDlgItemInt（）

功能：

获取控件中里面字符串并转换成int类型返回·BOOLbSigned // signed or unsigned value.

原型参数：


UINT GetDlgItemInt(

HWND hDlg, // handle to dialog box；要获取数值的窗口句柄（窗口名称）

int nIDDlgItem, // control identifier；要获取数值的控件名字（比如IDC_***）

BOOL *lpTranslated, // success state；布尔变量的指针，一般定义为" NULL "

BOOL bSigned；有符号或无符号，一般定义为“ TRUE ”表示返回的是可正可负的值

);
```
  
  


   
**转载请注明出处：http://blog.csdn.net/qq_22642239/article/details/51540403**  


 

   


 

 

 

 

 

 

 

 

 

   


 

 

 

   
  


   


 

 

 

 

 

 

 

 

 

 

 

 **  
**

 **  
**

 **  
**

 ** **

   
 