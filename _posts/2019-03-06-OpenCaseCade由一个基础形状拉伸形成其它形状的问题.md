---
layout: post
title: OpenCaseCade由一个基础形状拉伸形成其它形状的问题
date: 2019-03-06 18:16:45
---

{{ page.title }}
================

<p class="meta">2019-03-06 18:16:45 - 深圳</p>

 版权声明：需要转载的请注明出处 
   使用OCC有一段时间了，一直没有记录这方面的内容，为了以后的学习，决定整理一下（技术有限，错误请指正）。

 OCC版本：6.8.0

 操作系统：windows（7）

 开发工具：vs2010，vs2017

 UI框架：MFC

 

 如题，今天的问题是关于OCC如何由一个基础的形状，通过拉伸，形成另一种图形，即三维视角。

 OCC源码里面提供了MFC有关的很多例子，这对我来说是一个很好的学习资源，好多问题都是从例子源码里面的到的思路，

 关于这个问题也是在稍微有点头绪的情况下去找的例子，这些都是惨不忍睹的探索过程，国内这方面的资料也不是很多，通过不断寻找找到了简单的实现方法那就是：BRepPrimAPI_MakePrism类

 这个类在OCC头文件BRepPrimAPI_MakePrism.hxx 中

 这里只看一下头文件，具体的实现源码就看个人兴趣爱好了，

 BRepPrimAPI_MakePrism.hxx 如下，全是导出函数，注释都是英文的（能看尽量自己阅读英文，不行就谷歌翻译吧）

 
```
 // This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _BRepPrimAPI_MakePrism_HeaderFile
#define _BRepPrimAPI_MakePrism_HeaderFile

#include <Standard.hxx>
#include <Standard_DefineAlloc.hxx>
#include <Standard_Macro.hxx>

#include <BRepSweep_Prism.hxx>
#include <BRepPrimAPI_MakeSweep.hxx>
#include <Standard_Boolean.hxx>
class TopoDS_Shape;
class gp_Vec;
class gp_Dir;
class BRepSweep_Prism;
class TopTools_ListOfShape;


//! Describes functions to build linear swept topologies, called prisms.
//! A prism is defined by:
//! -   a basis shape, which is swept, and
//! -   a sweeping direction, which is:
//! -   a vector for finite prisms, or
//! -   a direction for infinite or semi-infinite prisms.
//! The basis shape must not contain any solids.
//! The profile generates objects according to the following rules:
//! -   Vertices generate Edges
//! -   Edges generate Faces.
//! -   Wires generate Shells.
//! -   Faces generate Solids.
//! -   Shells generate Composite Solids
//! A MakePrism object provides a framework for:
//! -   defining the construction of a prism,
//! -   implementing the construction algorithm, and
//! -   consulting the result.
class BRepPrimAPI_MakePrism  : public BRepPrimAPI_MakeSweep
{
public:

  DEFINE_STANDARD_ALLOC

  
  //! Builds the prism of base S and vector V. If C is true,
  //! S is copied. If Canonize is true then generated surfaces
  //! are attempted to be canonized in simple types
  Standard_EXPORT BRepPrimAPI_MakePrism(const TopoDS_Shape& S, const gp_Vec& V, const Standard_Boolean Copy = Standard_False, const Standard_Boolean Canonize = Standard_True);
  
  //! Builds a semi-infinite or an infinite prism of base S.
  //! If Inf is true the prism  is infinite, if Inf is false
  //! the prism is semi-infinite (in the direction D).  If C
  //! is true S is copied (for semi-infinite prisms).
  //! If Canonize is true then generated surfaces
  //! are attempted to be canonized in simple types
  Standard_EXPORT BRepPrimAPI_MakePrism(const TopoDS_Shape& S, const gp_Dir& D, const Standard_Boolean Inf = Standard_True, const Standard_Boolean Copy = Standard_False, const Standard_Boolean Canonize = Standard_True);
  
  //! Returns the internal sweeping algorithm.
  Standard_EXPORT  const  BRepSweep_Prism& Prism()  const;
  
  //! Builds the resulting shape (redefined from MakeShape).
  Standard_EXPORT virtual   void Build() ;
  
  //! Returns the  TopoDS  Shape of the bottom of the prism.
  Standard_EXPORT   TopoDS_Shape FirstShape() ;
  
  //! Returns the TopoDS Shape of the top of the prism.
  //! In the case of a finite prism, FirstShape returns the
  //! basis of the prism, in other words, S if Copy is false;
  //! otherwise, the copy of S belonging to the prism.
  //! LastShape returns the copy of S translated by V at the
  //! time of construction.
  Standard_EXPORT   TopoDS_Shape LastShape() ;
  
  //! Returns ListOfShape from TopTools.
  Standard_EXPORT virtual  const  TopTools_ListOfShape& Generated (const TopoDS_Shape& S) ;
  
  //! Returns the TopoDS Shape of the bottom  of the  prism.
  //! generated  with  theShape (subShape of the  generating shape).
  Standard_EXPORT   TopoDS_Shape FirstShape (const TopoDS_Shape& theShape) ;
  
  //! Returns the  TopoDS  Shape of the top  of  the  prism.
  //! generated  with  theShape (subShape of the  generating shape).
  Standard_EXPORT   TopoDS_Shape LastShape (const TopoDS_Shape& theShape) ;

protected:



private:

  BRepSweep_Prism myPrism;


};


#endif // _BRepPrimAPI_MakePrism_HeaderFile

```
 这个头文见虽然不算长，但内容还是挺多的。

 回到正题，根据今天的问题，首先要构造一个基础图形，何为基础图形，看一下头文件，BRepPrimAPI_MakePrism类的两个构造函数，这两个函数就是实现将一个基础图形向着某一个方向拉伸，具体拉伸的长度，有几方法实现。

 我这里主要是用的是第一个构造函数，其他的一些方法可以获取一些拉伸后图形的基本元素等，可以结合自身情况查阅注释使用。

 下面是第一个构造函数：

 
```
 Standard_EXPORT BRepPrimAPI_MakePrism(const TopoDS_Shape& S, const gp_Vec& V, const Standard_Boolean Copy = Standard_False, const Standard_Boolean Canonize = Standard_True);
```
 **const TopoDS_Shape& S**：第一个参数，类型是TopoDS_Shape，也是一个类，这个其实就是我们所说的基本形状。

 在OCC里面可以是以下几种：

 TopoDS_Edge（边，可以自己由两点构成）

 TopoDS_Wire（由边组成的线框，可以自己在三维空间生成点，点构成边，然后构成线框）

 TopoDS_Face（面，可以由自定义线框构成，也可以采用现有的OCC API生成）

 

 **const gp_Vec& V：**第二个参数，类型是gp_Vec，也是一个类，这个主要就是指定拉伸方向，有几种实现方式，可以在类的头文件里看一下，我选择的是一种比较直观的方法，直接在Z轴方向拉伸，在下面代码中。

 其他几个参数可以不写，有默认值，如果需要做进一步编辑，可以看一下英文注释。

 下面是我在项目代码中的使用例子：

 
```
     BRepBuilderAPI_MakeWire mkw;
	TopoDS_Edge E11 = BRepBuilderAPI_MakeEdge(gp_Pnt(40.,0.,0.), gp_Pnt(82.5,25.,0.));
	TopoDS_Edge E12 = BRepBuilderAPI_MakeEdge(gp_Pnt(82.5,25.,0.), gp_Pnt(42.5,93.,0.));
	TopoDS_Edge E13 = BRepBuilderAPI_MakeEdge(gp_Pnt(42.5,93.,0.), gp_Pnt(0.,68.,0.));
	TopoDS_Edge E14 = BRepBuilderAPI_MakeEdge(gp_Pnt(0.,68.,0.), gp_Pnt(40.,0.,0.));
	TopoDS_Wire W1 = BRepBuilderAPI_MakeWire(E11,E12,E13,E14);

	//TopoDS_Shape S = BRepPrimAPI_MakePrism(W1,gp_Vec(0.,0.,50));                          //线框TopoDS_Wire在指定向量拉伸
	//TopoDS_Shape S = BRepPrimAPI_MakePrism(E14,gp_Vec(0.,0.,50));                           //边TopoDS_Edge在指定向量拉伸
	TopoDS_Shape S =BRepPrimAPI_MakePrism(BRepBuilderAPI_MakeFace(W1),gp_Vec(0.,0.,50));   //面TopoDS_Face在指定向量拉伸
	Handle(AIS_Shape) ais1 = new AIS_Shape(S);                                                
	
	
	myAISContext->SetColor(ais1,Quantity_NOC_CYAN2,Standard_False); 
	myAISContext->SetMaterial(ais1,Graphic3d_NOM_PLASTIC,Standard_False);   
	myAISContext->Display(ais1,Standard_False);
	myAISContext->SetCurrentObject(ais1,Standard_False);
	Fit();	
```
 **下面看一下拉伸后的效果（部分图形因为鼠标旋转可能位置不是比较一致，旋转一下位置即可）**

 **第一种：**由基础图形（面）拉伸成长方体：

 基础图形面如下：

 ![](https://img-blog.csdnimg.cn/20190306180022223.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

 拉伸后的三维图形如下：

 

 ![](https://img-blog.csdnimg.cn/20190306180048969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

 

 **第二种：**由基础图形（边）拉伸成面：

 基础边如下：

 ![](https://img-blog.csdnimg.cn/20190306180601743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

 拉伸后的面如下：

 ![](https://img-blog.csdnimg.cn/20190306180614434.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

 

 **第三种：**由基础图形（线框）拉伸成实体：

 基础线框如下：

 ![](https://img-blog.csdnimg.cn/20190306181245147.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

 拉伸后的实体如下：

 ![](https://img-blog.csdnimg.cn/20190306181255103.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjQyMjM5,size_16,color_FFFFFF,t_70)

   
 
