---
title: c++面试题
date: 2016-10-18 15:06:18
tags: CSDN迁移
---
   C#C++C多线程面试  
 1.static有什么用途？（请至少说明两种）  
 1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。  
 2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。  
 3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用  
   
   
 2.引用与指针有什么区别？  
 1) 引用必须被初始化，指针不必。  
 2) 引用初始化以后不能被改变，指针可以改变所指的对象。  
 3) 不存在指向空值的引用，但是存在指向空值的指针。  
   
   
 3.描述实时系统的基本特性  
 在特定时间内完成特定的任务，实时性与可靠性。  
   
   
 4.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？  
 全局变量储存在静态数据库，局部变量在堆栈。  
   
   
 5.什么是平衡二叉树？  
 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。  
   
   
 6.堆栈溢出一般是由什么原因导致的？  
 没有回收垃圾资源。  
   
   
 7.什么函数不能声明为虚函数？  
 constructor函数不能声明为虚函数。  
   
   
 8.冒泡排序算法的时间复杂度是什么？  
 时间复杂度是O(n^2)。  
   
   
 9.写出float x 与“零值”比较的if语句。  
 if(x>0.000001&&x<-0.000001)  
   
   
 10.Internet采用哪种网络协议？该协议的主要层次结构？  
 Tcp/Ip协议  
 主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。  
   
   
 11.Internet物理地址和IP地址转换采用什么协议？  
 ARP (Address Resolution Protocol)（地址解析協議）  
   
   
 12.IP地址的编码分为哪俩部分？  
 IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。  
   
   
 13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。  
 循环链表，用取余操作做  
   
   
   
   
 14.不能做switch()的参数类型是：  
 switch的参数不能为实型。  
   
   
    
   
   
 1.写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a的值(3分)  
 int a = 4;  
 (A)a += (a++); (B) a += (++a) ;(C) (a++) += a;(D) (++a) += (a++);  
 a = ?  
 答：C错误，左侧不是一个有效变量，不能赋值，可改为(++a) += a;  
 改后答案依次为9,10,10,11  
   
   
 2.某32位系统下, C++程序，请计算sizeof 的值(5分).  
 char str[] = “http://www.ibegroup.com/”  
 char *p = str ;  
 int n = 10;  
 请计算  
 sizeof (str ) = ？（1）  
 sizeof ( p ) = ？（2）  
 sizeof ( n ) = ？（3）  
 void Foo ( char str[100]){  
 请计算  
 sizeof( str ) = ？（4）  
 }  
 void *p = malloc( 100 );  
 请计算  
 sizeof ( p ) = ？（5）  
 答：（1）17 （2）4 （3） 4 （4）4 （5）4  
   
   
 3. 回答下面的问题. (4分)  
 (1).头文件中的 ifndef/define/endif 干什么用？预处理  
 答：防止头文件被重复引用  
 (2). ＃i nclude 和 ＃i nclude “filename.h” 有什么区别？  
 答：前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。  
 (3).在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？  
 答：函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern "C"修饰的变  
 量和函数是按照C语言方式编译和连接的。由于编译后的名字不同，C++程序不能直接调  
 用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。  
 (4). switch()中不允许的数据类型是?  
 答：实型  
   
   
 4. 回答下面的问题(6分)  
 (1).Void GetMemory(char **p, int num){  
 *p = (char *)malloc(num);  
 }  
 void Test(void){  
 char *str = NULL;  
 GetMemory(&str, 100);  
 strcpy(str, "hello");  
 printf(str);  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：输出“hello”  
 (2). void Test(void){  
 char *str = (char *) malloc(100);  
 strcpy(str, “hello”);  
 free(str);  
 if(str != NULL){  
 strcpy(str, “world”);  
 printf(str);  
 }  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：输出“world”  
 (3). char *GetMemory(void){  
 char p[] = "hello world";  
 return p;  
 }  
 void Test(void){  
 char *str = NULL;  
 str = GetMemory();  
 printf(str);  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：无效的指针，输出不确定  
   
   
 5. 编写strcat函数(6分)  
 已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc);  
 其中strDest 是目的字符串，strSrc 是源字符串。  
 （1）不调用C++/C 的字符串库函数，请编写函数 strcat  
 答：  
 VC源码：  
 char * __cdecl strcat (char * dst, const char * src)  
 {  
 char * cp = dst;  
 while( *cp )  
 cp++; /* find end of dst */  
 while( *cp++ = *src++ ) ; /* Copy src to end of dst */  
 return( dst ); /* return dst */  
 }  
 （2）strcat能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？  
 答：方便赋值给其他变量  
   
   
 6.MFC中CString是类型安全类么？  
 答：不是，其它数据类型转换到CString可以使用CString的成员函数Format来转换  
   
   
 7.C++中为什么用模板类。  
 答：(1)可用来创建动态增长和减小的数据结构  
 （2）它是类型无关的，因此具有很高的可复用性。  
 （3）它在编译时而不是运行时检查数据类型，保证了类型安全  
 （4）它是平台无关的，可移植性  
 （5）可用于基本数据类型  
   
   
 8.CSingleLock是干什么的。  
 答：同步多个线程对一个数据类的同时访问  
   
   
 9.NEWTEXTMETRIC 是什么。  
 答：物理字体结构，用来设置字体的高宽大小  
   
   
 10.程序什么时候应该使用线程，什么时候单线程效率高。  
 答：1．耗时的操作使用线程，提高应用程序响应  
 2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。  
 3．多CPU系统中，使用线程提高CPU利用率  
 4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独  
 立的运行部分，这样的程序会利于理解和修改。  
 其他情况都使用单线程。  
   
   
 11.Windows是内核级线程么。  
 答：见下一题  
   
   
 12.Linux有内核级线程么。  
 答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两  
 种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序  
 中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度  
 和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现  
 ，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一  
 种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部  
 需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支  
 ，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线  
 程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不  
 到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占  
 用了更多的系统开支。  
 Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程  
   
   
 13.C++中什么数据分配在栈或堆中，New分配数据是在近堆还是远堆中？  
 答：栈: 存放局部变量，函数调用参数,函数返回值，函数返回地址。由系统管理  
 堆: 程序运行时动态申请，new 和 malloc申请的内存就在堆上  
   
   
 14.使用线程是如何防止出现大的波峰。  
 答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提  
 高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队  
 等候。  
   
   
 15函数模板与类模板有什么区别？  
 答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化  
 必须由程序员在程序中显式地指定。  
   
   
 16一般数据库若出现日志满了，会出现什么情况，是否还能使用？  
 答：只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记  
 录日志。也就是说基本上处于不能使用的状态。  
   
   
 17 SQL Server是否支持行级锁，有什么好处？  
 答：支持，设立封锁机制主要是为了对并发操作进行控制，对干扰进行封锁，保证数据  
 的一致性和准确性，行级封锁确保在用户取得被更新的行到该行进行更新这段时间内不  
 被其它用户所修改。因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。  
   
   
 18如果数据库满了会出现什么情况，是否还能使用？  
 答：见16  
   
   
 19 关于内存对齐的问题以及sizof()的输出  
 答：编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能  
 地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问  
 ；然而，对齐的内存访问仅需要一次访问。  
   
   
 20 int i=10, j=10, k=3; k*=i+j; k最后的值是？  
 答：60，此题考察优先级，实际写成： k*=(i+j);，赋值运算符优先级最低  
   
   
 21.对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现?  
 答：将操作多个表的操作放入到事务中进行处理  
   
   
 22.TCP/IP 建立连接的过程?(3-way shake)  
 答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。  
  第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状  
 态，等待服务器确认；  
 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个  
 SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；  
  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)  
 ，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。  
   
   
 23.ICMP是什么协议,处于哪一层?  
 答：Internet控制报文协议，处于网络层（IP层）  
   
   
 24.触发器怎么工作的?  
 答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT  
 、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数  
 据的处理必须符合由这些SQL 语句所定义的规则。  
   
   
 25.winsock建立连接的主要实现步骤?  
 答：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（）  
 等待客户端连接。  
 客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（  
 ），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。  
 服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连  
 接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesock  
 et()关闭套接字。  
   
   
 26.动态连接库的两种方式?  
 答：调用一个DLL中的函数有两种方法：  
 1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数  
 ，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向  
 系统提供了载入DLL时所需的信息及DLL函数定位。  
 2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa  
 dLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的  
 出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了  
 。  
   
   
 27.IP组播有那些好处?  
 答：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧  
 消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包  
 到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无  
 论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播  
 技术的核心就是针对如何节约网络资源的前提下保证服务质量。  
   
   
 转自：http://www.cnblogs.com/bluespot/archive/2008/03/11/1100661.html  
 →『C/C++面试题大汇总』  
 8  
 推荐最近因为找工作，收集了很多C语言方面方面的面试题以及答案。现在新工作搞定了，决定把这些资料发出来，送给有需要的朋友，免得再象我一样到处搜寻，实在辛苦。  
   
   
 发布之前先申明两点：  
 1 所有资料来自网络(主要是CSDN)，本人只是收集和转发。  
 2 所有问题解答(尤其是代码)只是参考，不保证正确。  
   
   
 先发基本问题，再发编程问题..........  
   
   
 想成为嵌入式程序员应知道的0x10个基本问题:  
 预处理器（Preprocessor）  
   
   
 1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）  
 #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL  
 我在这想看到几件事情：  
 1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）  
 2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。  
 3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。  
 4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。  
   
   
 2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。  
 #define MIN(A,B) （（A） <= (B) ? (A) : (B))  
 这个测试是为下面的目的而设的：  
 1) 标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。  
 2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。  
 3) 懂得在宏中小心地把参数用括号括起来  
 4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？  
 least = MIN(*p++, b);  
   
   
 3. 预处理器标识#error的目的是什么？  
 如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。  
   
   
   
   
 死循环（Infinite loops）  
   
   
 4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？  
 这个问题用几个解决方案。我首选的方案是：  
   
   
 while(1)  
 {  
   
   
 }  
   
   
 一些程序员更喜欢如下方案：  
   
   
 for(;;)  
 {  
   
   
 }  
   
   
 这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。  
   
   
 第三个方案是用 goto  
 Loop:  
 ...  
 goto Loop;  
 应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。  
   
   
   
   
 数据声明（Data declarations）  
   
   
 5. 用变量a给出下面的定义  
 a) 一个整型数（An integer）  
 b)一个指向整型数的指针（ A pointer to an integer）  
 c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r  
 d)一个有10个整型数的数组（ An array of 10 integers）  
 e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）  
 f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）  
 g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）  
 h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）  
   
   
 答案是：  
 a) int a; // An integer  
 b) int *a; // A pointer to an integer  
 c) int **a; // A pointer to a pointer to an integer  
 d) int a[10]; // An array of 10 integers  
 e) int *a[10]; // An array of 10 pointers to integers  
 f) int (*a)[10]; // A pointer to an array of 10 integers  
 g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer  
 h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer  
   
   
 人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？  
   
   
 Static  
   
   
 6. 关键字static的作用是什么？  
 这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：  
 1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。  
 2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。  
 3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。  
   
   
 大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。  
   
   
 Const  
   
   
 7．关键字const有什么含意？  
 我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）  
 如果应试者能正确回答这个问题，我将问他一个附加的问题：  
 下面的声明都是什么意思？  
   
   
 const int a;  
 int const a;  
 const int *a;  
 int * const a;  
 int const * a const;  
   
   
 /******/  
 前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：  
 1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）  
 2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。  
 3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。  
   
   
   
   
 Volatile  
   
   
 8. 关键字volatile有什么含意?并给出三个不同的例子。  
 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：  
 1) 并行设备的硬件寄存器（如：状态寄存器）  
 2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)  
 3) 多线程应用中被几个任务共享的变量  
   
   
 回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。  
 假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。  
 1)一个参数既可以是const还可以是volatile吗？解释为什么。  
 2); 一个指针可以是volatile 吗？解释为什么。  
 3); 下面的函数有什么错误：  
   
   
 int square(volatile int *ptr)  
 {  
 return *ptr * *ptr;  
 }  
   
   
 下面是答案：  
 1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。  
 2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。  
 3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：  
   
   
 int square(volatile int *ptr)  
 {  
 int a,b;  
 a = *ptr;  
 b = *ptr;  
 return a * b;  
 }  
   
   
 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：  
   
   
 long square(volatile int *ptr)  
 {  
 int a;  
 a = *ptr;  
 return a * a;  
 }  
   
   
 位操作（Bit manipulation）  
   
   
 9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。  
 对这个问题有三种基本的反应  
 1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。  
 2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。  
 3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：  
   
   
 #define BIT3 (0x1 << 3)  
 static int a;  
   
   
 void set_bit3(void)  
 {  
 a |= BIT3;  
 }  
 void clear_bit3(void)  
 {  
 a &= ~BIT3;  
 }  
   
   
 一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。  
   
   
   
   
 访问固定的内存位置（Accessing fixed memory locations）  
   
   
 10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。  
 这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：  
 int *ptr;  
 ptr = (int *)0x67a9;  
 *ptr = 0xaa55;  
   
   
 A more obscure approach is:  
 一个较晦涩的方法是：  
   
   
 *(int * const)(0x67a9) = 0xaa55;  
   
   
 即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。  
   
   
 中断（Interrupts）  
   
   
 11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。  
   
   
 __interrupt double compute_area (double radius)  
 {  
 double area = PI * radius * radius;  
 printf("\nArea = %f", area);  
 return area;  
 }  
   
   
 这个函数有太多的错误了，以至让人不知从何说起了：  
 1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。  
 2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。  
 3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。  
 4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。  
   
   
   
   
 代码例子（Code examples）  
   
   
 12 . 下面的代码输出是什么，为什么？  
   
   
 void foo(void)  
 {  
 unsigned int a = 6;  
 int b = -20;  
 (a+b > 6) ? puts("> 6") : puts("<= 6");  
 }  
 这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。  
   
   
 13. 评价下面的代码片断：  
   
   
 unsigned int zero = 0;  
 unsigned int compzero = 0xFFFF;  
 /*1's complement of zero */  
   
   
 对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：  
   
   
 unsigned int compzero = ~0;  
   
   
 这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。  
 到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...  
   
   
 动态内存分配（Dynamic memory allocation）  
   
   
 14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？  
 这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：  
 下面的代码片段的输出是什么，为什么？  
   
   
 char *ptr;  
 if ((ptr = (char *)malloc(0)) == NULL)  
 puts("Got a null pointer");  
 else  
 puts("Got a valid pointer");  
   
   
 这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。  
   
   
 Typedef  
   
   
 15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：  
   
   
 #define dPS struct s *  
 typedef struct s * tPS;  
   
   
 以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？  
 这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：  
   
   
 dPS p1,p2;  
 tPS p3,p4;  
   
   
 第一个扩展为  
   
   
 struct s * p1, p2;  
 .  
 上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。晦涩的语法  
   
   
 16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？  
   
   
 int a = 5, b = 7, c;  
 c = a+++b;  
   
   
 这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：  
   
   
 c = a++ + b;  
   
   
 因此, 这段代码持行后a = 6, b = 7, c = 12。  
 如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。  
   
   
 华为笔试题  
 1.写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a的值(3分)  
 int a = 4;  
 (A)a += (a++); (B) a += (++a) ;(C) (a++) += a;(D) (++a) += (a++);  
 a = ?  
 答：C错误，左侧不是一个有效变量，不能赋值，可改为(++a) += a;  
 改后答案依次为9,10,10,11  
   
   
 2.某32位系统下, C++程序，请计算sizeof 的值(5分).  
 char str[] = “http://www.ibegroup.com/”  
 char *p = str ;  
 int n = 10;  
 请计算  
 sizeof (str ) = ？（1）  
 sizeof ( p ) = ？（2）  
 sizeof ( n ) = ？（3）  
 void Foo ( char str[100]){  
 请计算  
 sizeof( str ) = ？（4）  
 }  
 void *p = malloc( 100 );  
 请计算  
 sizeof ( p ) = ？（5）  
 答：（1）17 （2）4 （3） 4 （4）4 （5）4  
   
   
 3. 回答下面的问题. (4分)  
 (1).头文件中的 ifndef/define/endif 干什么用？预处理  
 答：防止头文件被重复引用  
 (2). ＃i nclude 和 ＃i nclude “filename.h” 有什么区别？  
 答：前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。  
 (3).在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？  
 答：函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern "C"修饰的变  
 量和函数是按照C语言方式编译和连接的。由于编译后的名字不同，C++程序不能直接调  
 用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。  
 (4). switch()中不允许的数据类型是?  
 答：实型  
   
   
 4. 回答下面的问题(6分)  
 (1).Void GetMemory(char **p, int num){  
 *p = (char *)malloc(num);  
 }  
 void Test(void){  
 char *str = NULL;  
 GetMemory(&str, 100);  
 strcpy(str, "hello");  
 printf(str);  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：输出“hello”  
 (2). void Test(void){  
 char *str = (char *) malloc(100);  
 strcpy(str, “hello”);  
 free(str);  
 if(str != NULL){  
 strcpy(str, “world”);  
 printf(str);  
 }  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：输出“world”  
 (3). char *GetMemory(void){  
 char p[] = "hello world";  
 return p;  
 }  
 void Test(void){  
 char *str = NULL;  
 str = GetMemory();  
 printf(str);  
 }  
 请问运行Test 函数会有什么样的结果？  
 答：无效的指针，输出不确定  
   
   
 5. 编写strcat函数(6分)  
 已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc);  
 其中strDest 是目的字符串，strSrc 是源字符串。  
 （1）不调用C++/C 的字符串库函数，请编写函数 strcat  
 答：  
 VC源码：  
 char * __cdecl strcat (char * dst, const char * src)  
 {  
 char * cp = dst;  
 while( *cp )  
 cp++; /* find end of dst */  
 while( *cp++ = *src++ ) ; /* Copy src to end of dst */  
 return( dst ); /* return dst */  
 }  
 （2）strcat能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？  
 答：方便赋值给其他变量  
   
   
 6.MFC中CString是类型安全类么？  
 答：不是，其它数据类型转换到CString可以使用CString的成员函数Format来转换  
   
   
 7.C++中为什么用模板类。  
 答：(1)可用来创建动态增长和减小的数据结构  
 （2）它是类型无关的，因此具有很高的可复用性。  
 （3）它在编译时而不是运行时检查数据类型，保证了类型安全  
 （4）它是平台无关的，可移植性  
 （5）可用于基本数据类型  
   
   
 8.CSingleLock是干什么的。  
 答：同步多个线程对一个数据类的同时访问  
   
   
 9.NEWTEXTMETRIC 是什么。  
 答：物理字体结构，用来设置字体的高宽大小  
   
   
 10.程序什么时候应该使用线程，什么时候单线程效率高。  
 答：1．耗时的操作使用线程，提高应用程序响应  
 2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。  
 3．多CPU系统中，使用线程提高CPU利用率  
 4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独  
 立的运行部分，这样的程序会利于理解和修改。  
 其他情况都使用单线程。  
   
   
 11.Windows是内核级线程么。  
 答：见下一题  
   
   
 12.Linux有内核级线程么。  
 答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两  
 种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序  
 中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度  
 和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现  
 ，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一  
 种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部  
 需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支  
 ，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线  
 程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不  
 到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占  
 用了更多的系统开支。  
 Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程  
   
   
 13.C++中什么数据分配在栈或堆中，New分配数据是在近堆还是远堆中？  
 答：栈: 存放局部变量，函数调用参数,函数返回值，函数返回地址。由系统管理  
 堆: 程序运行时动态申请，new 和 malloc申请的内存就在堆上  
   
   
 14.使用线程是如何防止出现大的波峰。  
 答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提  
 高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队  
 等候。  
   
   
 15函数模板与类模板有什么区别？  
 答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化  
 必须由程序员在程序中显式地指定。  
   
   
 16一般数据库若出现日志满了，会出现什么情况，是否还能使用？  
 答：只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记  
 录日志。也就是说基本上处于不能使用的状态。  
   
   
 17 SQL Server是否支持行级锁，有什么好处？  
 答：支持，设立封锁机制主要是为了对并发操作进行控制，对干扰进行封锁，保证数据  
 的一致性和准确性，行级封锁确保在用户取得被更新的行到该行进行更新这段时间内不  
 被其它用户所修改。因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。  
   
   
 18如果数据库满了会出现什么情况，是否还能使用？  
 答：见16  
   
   
 19 关于内存对齐的问题以及sizof()的输出  
 答：编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能  
 地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问  
 ；然而，对齐的内存访问仅需要一次访问。  
   
   
 20 int i=10, j=10, k=3; k*=i+j; k最后的值是？  
 答：60，此题考察优先级，实际写成： k*=(i+j);，赋值运算符优先级最低  
   
   
 21.对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现?  
 答：将操作多个表的操作放入到事务中进行处理  
   
   
 22.TCP/IP 建立连接的过程?(3-way shake)  
 答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。  
  第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状  
 态，等待服务器确认；  
 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个  
 SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；  
  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)  
 ，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。  
   
   
 23.ICMP是什么协议,处于哪一层?  
 答：Internet控制报文协议，处于网络层（IP层）  
   
   
 24.触发器怎么工作的?  
 答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT  
 、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数  
 据的处理必须符合由这些SQL 语句所定义的规则。  
   
   
 25.winsock建立连接的主要实现步骤?  
 答：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（）  
 等待客户端连接。  
 客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（  
 ），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。  
 服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连  
 接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesock  
 et()关闭套接字。  
   
   
 26.动态连接库的两种方式?  
 答：调用一个DLL中的函数有两种方法：  
 1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数  
 ，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向  
 系统提供了载入DLL时所需的信息及DLL函数定位。  
 2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa  
 dLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的  
 出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了  
 。  
   
   
 27.IP组播有那些好处?  
 答：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧  
 消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包  
 到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无  
 论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播  
 技术的核心就是针对如何节约网络资源的前提下保证服务质量。  
   
   
 1.static有什么用途？（请至少说明两种）  
 1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。  
 2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。  
 3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用  
   
   
 2.引用与指针有什么区别？  
 1) 引用必须被初始化，指针不必。  
 2) 引用初始化以后不能被改变，指针可以改变所指的对象。  
 3) 不存在指向空值的引用，但是存在指向空值的指针。  
   
   
 3.描述实时系统的基本特性  
 在特定时间内完成特定的任务，实时性与可靠性。  
   
   
 4.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？  
 全局变量储存在静态数据库，局部变量在堆栈。  
   
   
 5.什么是平衡二叉树？  
 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。  
   
   
 6.堆栈溢出一般是由什么原因导致的？  
 没有回收垃圾资源。  
   
   
 7.什么函数不能声明为虚函数？  
 constructor函数不能声明为虚函数。  
   
   
 8.冒泡排序算法的时间复杂度是什么？  
 时间复杂度是O(n^2)。  
   
   
 9.写出float x 与“零值”比较的if语句。  
 if(x>0.000001&&x<-0.000001)  
   
   
 10.Internet采用哪种网络协议？该协议的主要层次结构？  
 Tcp/Ip协议  
 主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。  
   
   
 11.Internet物理地址和IP地址转换采用什么协议？  
 ARP (Address Resolution Protocol)（地址解析協議）  
   
   
 12.IP地址的编码分为哪俩部分？  
 IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。  
   
   
 13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。  
 循环链表，用取余操作做  
 14.不能做switch()的参数类型是：  
 switch的参数不能为实型。  
   
   
 華為  
 1、局部变量能否和全局变量重名？  
 答：能，局部会屏蔽全局。要用全局变量，需要使用"::"  
 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。  
   
   
 2、如何引用一个已经定义过的全局变量？  
 答：extern  
 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。  
   
   
 3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？  
 答：可以，在不同的C文件中以static形式来声明同名全局变量。  
 可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。  
   
   
 4、语句for( ；1 ；)有什么问题？它是什么意思？  
 答：无限循环，和while(1)相同。  
   
   
 5、do……while和while……do有什么区别？  
 答：前一个循环一遍再判断，后一个判断以后再循环。  
   
   
 6、请写出下列代码的输出内容  
 ＃i nclude<stdio.h>  
 main()  
 {  
 int a,b,c,d;  
 a=10;  
 b=a++;  
 c=++a;  
 d=10*a++;  
 printf("b，c，d：%d，%d，%d"，b，c，d）;  
 return 0;  
 }  
 答：10，12，120  
   
   
 1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？  
 答：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。  
 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。  
 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件  
 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;  
 static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；  
 static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  
   
   
 2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。  
   
   
 3、设有以下说明和定义：  
 typedef union {long i; int k[5]; char c;} DATE;  
 struct data { int cat; DATE cow; double dog;} too;  
 DATE max;  
 则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____  
 答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20  
 data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.  
 所以结果是 20 + 32 = 52.  
 当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20  
   
   
 4、队列和栈有什么区别？  
 队列先进先出，栈后进先出  
   
   
 5、写出下列代码的输出内容  
 ＃i nclude<stdio.h>  
 int inc(int a)  
 {  
 return(++a);  
 }  
 int multi(int*a,int*b,int*c)  
 {  
 return(*c=*a**b);  
 }  
 typedef int(FUNC1)(int in);  
 typedef int(FUNC2) (int*,int*,int*);  
   
   
 void show(FUNC2 fun,int arg1, int*arg2)  
 {  
 INCp=&inc;  
 int temp =p(arg1);  
 fun(&temp,&arg1, arg2);  
 printf("%d\n",*arg2);  
 }  
   
   
 main()  
 {  
 int a;  
 show(multi,10,&a);  
 return 0;  
 }  
 答：110  
 7、请找出下面代码中的所以错误  
 说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”  
   
   
 1、＃i nclude"string.h"  
 2、main()  
 3、{  
 4、 char*src="hello,world";  
 5、 char* dest=NULL;  
 6、 int len=strlen(src);  
 7、 dest=(char*)malloc(len);  
 8、 char* d=dest;  
 9、 char* s=src[len];  
 10、 while(len--!=0)  
 11、 d++=s--;  
 12、 printf("%s",dest);  
 13、 return 0;  
 14、}  
 答：  
 方法1：  
 int main(){  
 char* src = "hello,world";  
 int len = strlen(src);  
 char* dest = (char*)malloc(len+1);//要为\0分配一个空间  
 char* d = dest;  
 char* s = &src[len-1];//指向最后一个字符  
 while( len-- != 0 )  
 *d++=*s--;  
 *d = 0;//尾部要加\0  
 printf("%s\n",dest);  
 free(dest);// 使用完，应当释放空间，以免造成内存汇泄露  
 return 0;  
 }  
 方法2：  
 ＃i nclude <stdio.h>  
 ＃i nclude <string.h>  
 main()  
 {  
 char str[]="hello,world";  
 int len=strlen(str);  
 char t;  
 for(int i=0; i<len/2; i++)  
 {  
 t=str[i];  
 str[i]=str[len-i-1]; str[len-i-1]=t;  
 }  
 printf("%s",str);  
 return 0;  
 }  
 1.-1,2,7,28,,126请问28和126中间那个数是什么？为什么？  
 第一题的答案应该是4^3-1=63  
 规律是n^3-1(当n为偶数0，2，4)  
 n^3+1(当n为奇数1，3，5)  
 答案：63  
 2.用两个栈实现一个队列的功能？要求给出算法和思路！  
 设2个栈为A,B, 一开始均为空.  
   
   
 入队:  
 将新元素push入栈A;  
   
   
 出队:  
 (1)判断栈B是否为空；  
 (2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；  
 (3)将栈B的栈顶元素pop出；  
   
   
 这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。3.在c语言库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？  
 函数名: atol  
 功 能: 把字符串转换成长整型数  
 用 法: long atol(const char *nptr);  
 程序例:  
 ＃i nclude <stdlib.h>  
 ＃i nclude <stdio.h>  
 int main(void)  
 {  
 long l;  
 char *str = "98765432";  
   
   
 l = atol(lstr);  
 printf("string = %s integer = %ld\n", str, l);  
 return(0);  
 }  
   
   
 2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?  
 c用宏定义，c++用inline  
 3.直接链接两个信令点的一组链路称作什么?  
 PPP点到点连接  
 4.接入网用的是什么接口?  
 5.voip都用了那些协议?  
 6.软件测试都有那些种类?  
 黑盒：针对系统功能的测试 白合：测试函数功能，各函数接口  
 7.确定模块的功能和模块的接口是在软件设计的那个队段完成的?  
 概要设计阶段  
 8.enum string  
 {  
 x1,  
 x2,  
 x3=10,  
 x4,  
 x5,  
 }x;  
 问x= 0x801005，0x8010f4 ;  
 9.unsigned char *p1;  
 unsigned long *p2;  
 p1=(unsigned char *)0x801000;  
 p2=(unsigned long *)0x810000;  
 请问p1+5= ;  
 p2+5= ;  
 三.选择题:  
 1.Ethternet链接到Internet用到以下那个协议?  
 A.HDLC;B.ARP;C.UDP;D.TCP;E.ID  
 2.属于网络层协议的是:  
 A.TCP;B.IP;C.ICMP;D.X.25  
 3.Windows消息调度机制是:  
 A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈;  
 4.unsigned short hash(unsigned short key)  
 {  
 return (key>>)%256  
 }  
 请问hash(16),hash(256)的值分别是:  
 A.1.16;B.8.32;C.4.16;D.1.32  
 四.找错题:  
 1.请问下面程序有什么错误?  
 int a[60][250][1000],i,j,k;  
 for(k=0;k<=1000;k++)  
 for(j=0;j<250;j++)  
 for(i=0;i<60;i++)  
 a[i][j][k]=0;  
 把循环语句内外换一下  
 2.#define Max_CB 500  
 void LmiQueryCSmd(Struct MSgCB * pmsg)  
 {  
 unsigned char ucCmdNum;  
 ......  
   
   
 for(ucCmdNum=0;ucCmdNum<Max_CB;ucCmdNum++)  
 {  
 ......;  
 }  
 死循环  
 3.以下是求一个数的平方的程序,请找出错误:  
 #define SQUARE(a)((a)*(a))  
 int a=5;  
 int b;  
 b=SQUARE(a++);  
 4.typedef unsigned char BYTE  
 int examply_fun(BYTE gt_len; BYTE *gt_code)  
 {   
 BYTE *gt_buf;  
 gt_buf=(BYTE *)MALLOC(Max_GT_Length);  
 ......  
 if(gt_len>Max_GT_Length)  
 {  
 return GT_Length_ERROR;   
 }  
 .......  
 }  
 五.问答题:  
 1.IP Phone的原理是什么?  
 IPV6  
 2.TCP/IP通信建立的过程怎样，端口有什么作用？  
 三次握手，确定是哪个应用程序使用该协议  
 3.1号信令和7号信令有什么区别，我国某前广泛使用的是那一种？  
 4.列举5种以上的电话新业务？  
   
   
 微软亚洲技术中心的面试题！！！  
 1．进程和线程的差别。  
 线程是指进程内的一个执行单元,也是进程内的可调度实体.  
 与进程的区别:  
 (1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位  
 (2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行  
 (3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.  
 (4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。  
 2.测试方法  
 人工测试：个人复查、抽查和会审  
 机器测试：黑盒测试和白盒测试  
   
   
 2．Heap与stack的差别。  
 Heap是堆，stack是栈。  
 Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。  
 Stack空间有限，Heap是很大的自由存储区  
 C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。  
 程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行  
 3．Windows下的内存是如何管理的？  
 4．介绍.Net和.Net的安全性。  
 5．客户端如何访问.Net组件实现Web Service？  
 6．C/C++编译器中虚表是如何完成的？  
 7．谈谈COM的线程模型。然后讨论进程内/外组件的差别。  
 8．谈谈IA32下的分页机制  
 小页(4K)两级分页模式，大页(4M)一级  
 9．给两个变量，如何找出一个带环单链表中是什么地方出现环的？  
 一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方  
 10．在IA32中一共有多少种办法从用户态跳到内核态？  
 通过调用门，从ring3到ring0，中断从ring3到ring0，进入vm86等等  
 11．如果只想让程序有一个实例运行，不能运行两个。像winamp一样，只能开一个窗口，怎样实现？  
 用内存映射或全局原子（互斥变量）、查找窗口句柄..  
 FindWindow，互斥，写标志到文件或注册表,共享内存。.    
 12．如何截取键盘的响应，让所有的‘a’变成‘b’？  
 键盘钩子SetWindowsHookEx  
  13．Apartment在COM中有什么用？为什么要引入？  
  14．存储过程是什么？有什么用？有什么优点？  
 我的理解就是一堆sql的集合，可以建立非常复杂的查询，编译运行，所以运行一次后，以后再运行速度比单独执行SQL快很多  
  15．Template有什么特点？什么时候用？  
 16．谈谈Windows DNA结构的特点和优点。  
   
   
   
   
 网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？  
 1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。  
 2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。  
 两者都可以提高程序的并发度，提高程序运行效率和响应时间。  
 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。  
   
   
 思科  
 1. 用宏定义写出swap（x，y）  
 #define swap(x, y)\  
 x = x + y;\  
 y = x - y;\  
 x = x - y;  
 2.数组a[N]，存放了1至N-1个数，其中某个数重复一次。写一个函数，找出被重复的数字.时间复杂度必须为o（N）函数原型：  
 int do_dup(int a[],int N)  
 3 一语句实现x是否为2的若干次幂的判断  
 int i = 512;  
 cout << boolalpha << ((i & (i - 1)) ? false : true) << endl;  
 4.unsigned int intvert(unsigned int x,int p,int n)实现对x的进行转换,p为起始转化位,n为需要转换的长度,假设起始点在右边.如x=0b0001 0001,p=4,n=3转换后x=0b0110 0001  
 unsigned int intvert(unsigned int x,int p,int n){  
 unsigned int _t = 0;  
 unsigned int _a = 1;  
 for(int i = 0; i < n; ++i){  
 _t |= _a;  
 _a = _a << 1;  
 }  
 _t = _t << p;  
 x ^= _t;  
 return x;  
 }  
   
   
 慧通：  
 什么是预编译  
 何时需要预编译：  
 １、总是使用不经常改动的大型代码体。  
 ２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。  
 char * const p;  
 char const * p  
 const char *p  
   
   
 上述三个有什么区别？  
 char * const p; //常量指针，p的值不可以修改  
 char const * p；//指向常量的指针，指向的常量值不可以改  
 const char *p； //和char const *p  
   
   
 char str1[] = "abc";  
 char str2[] = "abc";  
   
   
 const char str3[] = "abc";  
 const char str4[] = "abc";  
   
   
 const char *str5 = "abc";  
 const char *str6 = "abc";  
   
   
 char *str7 = "abc";  
 char *str8 = "abc";  
   
   
   
   
 cout << ( str1 == str2 ) << endl;  
 cout << ( str3 == str4 ) << endl;  
 cout << ( str5 == str6 ) << endl;  
 cout << ( str7 == str8 ) << endl;  
   
   
 结果是：0 0 1 1  
 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；  
 而str5,str6,str7,str8是指针，它们指向相同的常量区域。  
   
   
   
   
 12. 以下代码中的两个sizeof用法有问题吗？[C易]  
 void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母  
 {  
 for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )  
 if( 'a'<=str[i] && str[i]<='z' )  
 str[i] -= ('a'-'A' );  
 }  
 char str[] = "aBcDe";  
 cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;  
 UpperCase( str );  
 cout << str << endl;  
   
   
 答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。  
   
   
 一个32位的机器,该机器的指针是多少位  
 指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。  
   
   
 main()  
 {  
 int a[5]={1,2,3,4,5};  
 int *ptr=(int *)(&a+1);  
   
   
 printf("%d,%d",*(a+1),*(ptr-1));  
 }  
 输出：2,5  
 *(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5  
 &a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）  
 int *ptr=(int *)(&a+1);  
 则ptr实际是&(a[5]),也就是a+5  
 原因如下：  
 &a是数组指针，其类型为 int (*)[5];  
 而指针加1要根据指针类型加上一定的值，  
 不同类型的指针+1之后增加的大小不同  
 a是长度为5的int数组指针，所以要加 5*sizeof(int)  
 所以ptr实际是a[5]  
 但是prt与(&a+1)类型是不一样的(这点很重要)  
 所以prt-1只会减去sizeof(int*)  
 a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].  
   
   
   
   
 1.请问以下代码有什么问题：  
 int main()  
 {  
 char a;  
 char *str=&a;  
 strcpy(str,"hello");  
 printf(str);  
 return 0;  
 }  
 没有为str分配内存空间，将会发生异常  
 问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。  
   
   
 char* s="AAA";  
 printf("%s",s);  
 s[0]='B';  
 printf("%s",s);  
 有什么错？  
 "AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。  
 cosnt char* s="AAA";  
 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。  
   
   
 1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。  
 .#define Min(X, Y) ((X)>(Y)?(Y):(X))//结尾没有;  
 2、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。  
 while(1){}或者for(;;)  
 3、关键字static的作用是什么？  
 定义静态变量  
 4、关键字const有什么含意？  
 表示常量不可以修改的变量。  
 5、关键字volatile有什么含意？并举出三个不同的例子？  
 提示编译器对象的值可能在编译器未监测到的情况下改变。  
   
   
   
   
 int (*s[10])(int) 表示的是什么啊  
 int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。  
   
   
   
   
 1.有以下表达式：  
 int a=248; b=4;int const c=21;const int *d=&a;  
 int *const e=&b;int const *f const =&a;  
 请问下列表达式哪些会被编译器禁止？为什么？  
 *c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;  
 *c 这是个什么东东，禁止  
 *d 说了是const， 禁止  
 e = &a 说了是const 禁止  
 const *f const =&a; 禁止  
 2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;  
 有两种解法, 一种用算术算法, 一种用^(异或)  
 a = a + b;  
 b = a - b;  
 a = a - b;  
 or  
 a = a^b;// 只能对int,char..  
 b = a^b;  
 a = a^b;  
 or  
 a ^= b ^= a;  
 3.c和c++中的struct有什么不同？  
 c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private  
 4.＃i nclude <stdio.h>  
 ＃i nclude <stdlib.h>  
 void getmemory(char *p)  
 {  
 p=(char *) malloc(100);  
 strcpy(p,"hello world");  
 }  
 int main( )  
 {  
 char *str=NULL;  
 getmemory(str);  
 printf("%s/n",str);  
 free(str);  
 return 0;  
 }  
 程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险  
 5.char szstr[10];  
 strcpy(szstr,"0123456789");  
 产生什么结果？为什么？  
 长度不一样，会造成非法的OS  
 6.列举几种进程的同步机制，并比较其优缺点。  
 原子操作  
 信号量机制  
 自旋锁  
 管程，会合，分布式系统  
   
   
 7.进程之间通信的途径  
 共享存储系统  
 消息传递系统  
 管道：以文件系统为基础  
 11.进程死锁的原因  
 资源竞争及进程推进顺序非法  
 12.死锁的4个必要条件  
 互斥、请求保持、不可剥夺、环路  
 13.死锁的处理  
 鸵鸟策略、预防策略、避免策略、检测与解除死锁  
 15. 操作系统中进程调度策略有哪几种？  
 FCFS(先来先服务)，优先级，时间片轮转，多级反馈  
 8.类的静态成员和非静态成员有何区别？  
 类的静态成员每个类只有一个，非静态成员每个对象一个  
 9.纯虚函数如何定义？使用时应注意什么？  
 virtual void f()=0;  
 是接口，子类必须要实现  
 10.数组和链表的区别  
 数组：数据顺序存储，固定大小  
 连表：数据   
 