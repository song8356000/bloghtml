---
title: c++类的对象如何判断为空以及指针的赋值
date: 2018-10-23 09:34:40
tags: CSDN迁移
---
 版权声明：需要转载的请注明出处 https://blog.csdn.net/qq_22642239/article/details/83301985   
   在其他语言中比如（Java，c#）可以直接判断类的对象是否是null来判断类的对象是否为空，但是在c++中由于指针的存在，不能直接判断类的对象，而应该判断指向对象的指针是否为空。

 [C++语言](https://www.baidu.com/s?wd=C%2B%2B%E8%AF%AD%E8%A8%80&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)中，对象没有空和不空的概念，只有[对象指针](https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)才有空和不空的概念  
 判断[对象指针](https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)是否为空只需要和NULL常量进行比较即可  
 如果相等，则为空，否则不为空  
 另外对象虽然没有空和不空的概念，但是有有效和无效的概念  
 当对象的[析构函数](https://www.baidu.com/s?wd=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)被调用之后，对象即成为一个无效对象  
 一般可以用句柄法来判断  
 当对象被构造的时候，在一个全局的映射表中注册该对象，获得一个唯一句柄  
 判断的时候，用对象的句柄信息直接在映射表中进行查找，如果存在，则有效；如果不存在则无效  
 析构对象的时候，同时从映射表中删除该对象的句柄信息

 

 这里还涉及到一个基础问题 就是指针的赋值，如下：

 
```
 int	*p1;	
int	i=2;
p1=&i;
long *p2=3;	
```
 p2的赋值明显是错误的，long *p2=3 这是在把3这个地址赋值给指针变量p2 ， 但是3这个地址在计算中内存中是否可以访问（肯定不能访问）还是个未知数，这样很容易报错，非法访问内存，导致程序崩溃。

 在网上看到一位同学的说法，解释的更清晰点：

 
```
 long *p3=352; 这个和
long * p3; 
p3=352; //注意*不和p3这个变量名结合
是一样的，把352赋值给p3，一是类型不匹配，再者如果真的赋值成功（用强制转换）那么p3指向的地址是352，这个地址不一定是可用的。
long *p3;
*p3=352;
这段代码编译没错，向p3指向的地址中放入352这个数，但是p3的值没有初始化，它指向的地址不确定，所以p3现在是野指针，运行时也可能程序崩溃。总之，p3和*p3是不一样的。
可以这样：
long a;
long * p3=&a;   //等价于 long * p3; p3=&a;
*p3=352;
这时*p3和a都是352了。

char * c="abc";
这个等价于
char * c;
c="abc";
当然没问题，因为字符串或字符数组被编译器解析为地址。而字符串常量在编译时被编译器存贮在了静态的只读数据区。
```
 

   
 