---
title: WIN32汇编对话框的使用
date: 2016-03-25 20:09:36
tags: CSDN迁移
---
 版权声明：需要转载的请注明出处 https://blog.csdn.net/qq_22642239/article/details/50983141   
   **刚开始接触windows下的对话框，第一感觉就像是一个一般的窗口一样，没有图标，只有一个框框，中间有一些提示的控件（按钮，输入的文本框等）信息，在学习使用对话框的时候，资源文件的编写我感觉比编写实现对话框的代码要复杂一些，毕竟资源编译还要其他工具去编写，涉及许多意想不到的错误，有时候确实令人头大。下面就开始第一个自定义的对话框的实现过程：**

 **首先编写资源文件，我用的是ResEdit，添加一个对话框资源，然后在工具箱里面有好多可选的控件，如果要添加一个文本输入框的话，可以选择Static Text，然后在对话框内会显示出一个控件，可以用鼠标来移动位置，然后在属相 外观内找到标题 在后面输入需要在这个文本输入框内显示的文字信息，我还在例子资源中添加了一个简单的图标，命名为IDI_ICON1,添加一个图标的话也需要添加一个控件Picture Control，然后在属性 Misc 图像处点击下拉菜单加载已经命名好的图标文件IDI-ICON1，就可以看见图标文件在对话框的内显示出来，资源脚本如下：**

 


```
// Generated by ResEdit 1.6.6
// Copyright (C) 2006-2015
// http://www.resedit.net


#include <windows.h>
#include <commctrl.h>
#include <richedit.h>
//#include "resource.h"
#define IDD_DIALOG1                             100
#define IDI_ICON1                               101
//
// Dialog resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDD_DIALOG1 DIALOG 3, 6, 186, 95
STYLE DS_3DLOOK | DS_CENTER | DS_MODALFRAME | WS_CAPTION | WS_VISIBLE | WS_POPUP | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "Ms Shell Dlg"
{
    ICON            IDI_ICON1, -1, 47, 18, 21, 20, SS_ICON, WS_EX_LEFT
    PUSHBUTTON      "取消", IDCANCEL, 122, 76, 50, 14, 0, WS_EX_LEFT
    DEFPUSHBUTTON   "确认", IDOK, 15, 76, 50, 14, 0, WS_EX_LEFT
    LTEXT           "简单的对话框例子用Win32ASM编写", 0, 85, 20, 73, 17, SS_LEFT, WS_EX_LEFT
    CONTROL         "", -1,"Static",SS_ETCHEDHORZ, 1, 62, 180, 1, WS_EX_LEFT
}

//
// Icon resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDI_ICON1          ICON           "icon1.ico"
```
  
  
**当时编译资源脚本的时候，由于在CONTROL这一行，"Static"这一项没有写导致程序编译连接构建成功，但是可执行文件不能运行，后来加上之后从新编译可执行文件才可以运行，这是让我难忘的一处错误，因为它我纠结了好长时间。**

 **下面编写WIN32代码载入对话框：**

 ** **


```
 .386
                .model flat ,stdcall
                option casemap :none
;********************************************************
;Include文件定义
;********************************************************
include         windows.inc
include         user32.inc
includelib      user32.lib
include         kernel32.inc
includelib      kernel32.lib
;*******************************************************
;等值定义
;*******************************************************
IDD_DIALOG1     equ     64h     ;对话框
IDI_ICON1       equ     65h     ;图标;
;*******************************************************
;数据段
;*******************************************************
                .data?
hInstance       dd      ?
;*******************************************************
;代码段
;*******************************************************
                .code
_ProcDlgMain    proc    uses ebx edi esi hWnd ,wMsg,wParam,lParam
       mov     eax,wMsg
       .if     eax == WM_CLOSE
             invoke EndDialog,hWnd,NULL
       .elseif eax == WM_INITDIALOG
               invoke LoadIcon,hInstance,IDI_ICON1
               invoke SendMessage,hWnd,WM_SETICON,ICON_BIG,eax
       .elseif eax == WM_COMMAND
        mov    eax,wParam
        .if    ax == IDOK|| ax == IDCANCEL
              invoke EndDialog,hWnd,NULL
        .endif
       .else    
               mov    eax,FALSE
             ret
       .endif
       mov eax,TRUE
       ret
_ProcDlgMain    endp
;********************************************************
start:
                invoke GetModuleHandle,NULL
                mov    hInstance,eax
                invoke DialogBoxParam,hInstance,IDD_DIALOG1,\
                       NULL,offset _ProcDlgMain,NULL
                invoke ExitProcess,NULL
;******************************************************
                end    start
```
  
  
**代码依旧是消息处理，回调函数分支语句，标准的windows模板，都很熟悉了，需要注意的是，FALSE和TRUE,分别是函数的返回值，剩下的就是几个新的API函数：**

 **  
**

 


```
创建模态对话框的
DialogBoxParam（）
功能：
根据对话框模板资源创建一个模态的对话框。在显示对话框之前，函数将一个应用程序定义的值传到对话框过程中 WM_INITDIALOG 消息的 lParam 参数，应用程序可用此值来初始化对话框。
原型：
int DialogBoxParam(HINSTANCE hInstance，LPCTSTR IpTemplateName,HWND hWndParent， DLGPROC IPDialogFunc,LPARAM dwlnitParam);
参数：
hlnstance:标识一个模块的事例，该模块的可执行文件含有对话框模板。

IpTemplateName:标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模扳名，或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。

hWndParent:指定拥有对话框的窗口。

IpDialogFunc:指向对话框过程的指针。有关更详细的关于对话框过程的信息，请参见DialogProc。

dwInitParam:指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值。

返回值：

如果函数调用成功则返回值为在对函数EndDialog的调用中的nResult参数，该EndDialog函数用于中止对话框。如果函数调用失败，则返回值为-1。



创建非模态对话框的

CreateDialogParam（）

功能：

该函数根据对话框模板资源创建一个无模式的对话框。在显示对话框之前，函数把一个应用程序定义的值作为WM_INITDIALOG消息IParam参数传到对话框过程应用程序可用此值来初始化对话框控制

原型：

HWND CreateDialogParam(HINSTANCE hlnstancem,LPCTSTR IpTemplateName，HWND hWndParent，DLGPROCIpDialogFunc, LPARAM dwlniParam);

参数：


hlnstance:标识一个模块的事例,该模块的可执行文件含有对话框模板。

IpTemplateName:标识对话框模板。此参数可以指向一个以NULL结尾的字符串的指针,该字符串指定对话框模板名,或是指定对话框模板的资源标识符的一个整型值。如果此参数指定了一个资源标识符，则它的高位字一定为零且低位字一定含有标识符。一定用MAKEINTRESOURCE宏指令创建此值。

HwndParent:指定拥有对话框的窗口。

IpDialogFunc:指向对话框过程的指针。有关对话框过程的更详细的信息，请参见DialogProc。

dwlnitParam:指定传递到WM_INITDIALOG消息的IParam参数中的对话框过程的值。

返回值：
如果函数调用成功则返回值为指向对话框的窗口句柄。如果函数调用失败则返回值为NULL。



结束对话框函数

EndDialog（）

功能：

是清除一个模态对话框,并使系统中止对对话框的任何处理的函数。

原型：

BOOL EndDialog(HWND hDlg,int nResult);

参数：


hDlg:表示要被清除的对话框窗口。

NResult:指定从创建对话框函数返回到应用程序的值。

返回值：
如果函数调用成功，则返回值为非零值;如果函数调用失败则返回值为零。
```
  
  
**最后说一下对话框管理器，说到对话框管理器其实就像是在创建windows窗口的时候的DefWindowProc（）函数一样，自动对没有定义的窗口属性进行定义（这是windows干的），但是对于对话框来说，一些不处理的消息，不用再去在函数过程的最后去调用函数DefWindowProc（）来处理，这件事由对话框管理器自己来做，这样也省去了很多麻烦的事。**

 **还有一点就是利用DialogBoxParam（）函数创建的模态对话框（在用户关闭对话框之前不允许在同一程序中切换窗口，但可以切换到其它程序的窗口），在关闭时要用EndDialog（）函数关闭；但是用CreateDialogParam（）函数创建的非模态对话框（和模态对话框相反），关闭的时候需要用DestroyWindow（）函数来关闭关闭非模态对话框，这一点如果弄错的话，也会纠结半天，不容易找到错误的地方。**

 **再一点就是输入焦点的问题：（这点借签一下别人的回答很容易理解）**

 ****

 Windows是一个以消息为导向的系统，应用程序只能被动地等待用户按键的消息，不能主动地去读键盘的状态，也就是说，每当键盘上有个键被按下，系统就会发出一个按键消息给窗口，告诉它某个键被按下去了，只要鼠标移动一下，系统也会发出相应的消息，并把鼠标的坐标信息传给窗口。  
 Windows可以同时执行许多程序，但键盘只有一个，怎么判断由哪个窗口接收键盘及鼠标的消息呢？采用“输入焦点”（input focus）技术可以解决这个问题。只要某个窗口取得输入焦点，它不但会被提升到屏幕的最前面，颜色也会有所不同，所有的键盘消息就会导向该窗口，该窗口也成为“[活动窗口](http://baike.baidu.com/view/1988070.htm)”。  
 窗口如何取得输入焦点？通常被鼠标单击的窗口会得到输入焦点，除此之外，程序本身也可以利用SetFocus()来指定哪个窗口拥有输入焦点。  
 CWnd* CWnd::SetFocus();  
 如果调用某窗口的SetFocus()成员函数，该窗口就可以取得输入焦点，该函数返回前一个拥有输入焦点的窗口。  
 如果某个窗口的输入焦点被抢走，Windows系统就会发出WM_KILLFOCUS消息给这个失去输入焦点的窗口，同时还会告诉该窗口下一个取得输入焦点的窗口的[指针](http://baike.baidu.com/view/159417.htm)。而获得输入焦点的窗口则会收到WM_SETFOCUS消息。  
 消息响应函数分别为：  
 afx_msg void OnKillFocus(CWnd* pNewWnd);  
 其中的参数为失去输入焦点的窗口的[指针](http://baike.baidu.com/view/159417.htm)。  
 Afx_msg void OnSetFocus(CWnd* pOldWnd);  
 其中的参数为得到输入焦点的窗口的[指针](http://baike.baidu.com/view/159417.htm)。  
 到此对话框的实现就结束了，以后再来看。  
   


 

   
** **

 **  
**

   
 