---
title: 19.IDA-栈指针调节、设置函数特性
date: 2017-08-04 15:18:40
tags: CSDN迁移
---
   # 栈指针调节

 
> IDA会尽其所能跟踪函数内每一条指令上的栈指针的变化。IDA跟踪这种变化的准确程度，在很大程度上影响着函数的栈帧布局的准确程度。如果IDA无法确定一条指令是否更改了栈指针，你就需要手动调整栈指针   
>  如果一个函数调用了另一个使用stdcall调用约定的函数，就会出现上述情况，这是最简单的一种情况。如果被调用的函数位于IDA无法识别的共享库中（IDA拥有与许多常用库函数的签名和调用约定有关的信息），那么，IDA并不知道该函数使用了stdcall调用约定，也就无法认识到：被调用的函数会将栈指针修改后返回。因此，IDA会为函数的剩余部分提供一个错误的栈指针值。
> 
>  
 要进行栈调整，首先应选中进行调整的地址，并选择Edit▶Func-tions▶Change Stack Pointer（热键为ALT+K），然后指定栈指针更改的字节数（或右键菜单选中Change Stack Pointer）

 ![这里写图片描述](https://img-blog.csdn.net/20160203104838409)   
 注意更改的是选中的指令对栈的更改量，另栈是向低地址增长的，所以看图中指令，当前地址相对原始 esp小了0x8，指令是call callflow(int)，而callflow函数是__stdcall，所以DIFFERENCE 为4（内部平衡堆栈，向上增长4）

 如果IDA不能准确计算出callflow为__stdcall，那么就会出错（如前面提到的callflow为IDA不能识别的共享库的导入函数），那么我们需要在每个callflow的调用处进行栈调整，这很繁琐，而且容易出错   
 对于任意函数（包括库函数，导入函数），都可以选中此函数，再使用EDIT▶Functions▶Edit Functions…   
![这里写图片描述](https://img-blog.csdn.net/20160203111805457)   
 如果是导入函数，双击到.rdata目录，然后再使用EDIT▶Functions▶Edit Functions…   
![这里写图片描述](https://img-blog.csdn.net/20160203112052508)

 
> 栈调整对应Purged bytes，即
> 
>  
 
# []()函数特性

 函数名称（Name of function）:   
 - 提供另外一种更改函数名称的方法   
 起始地址(Start address):   
 - 函数中第一条指令的地址。通常，IDA会在分析过程中，或根据创建函数时所使用的地址，自动识别这个地址。   
 结束地址(End address):   
 - 函数中最后一条指令之后的地址。通常，它是函数的返回语句之后的指令的地址。记住，这个地址并不是函数的一部分，而是函数的最后一条指令之后的地址。   
 局部变量区(Local variables area):   
 - 函数的局部变量专用的栈字节数。多数情况下，IDA会通过分析函数的栈指针的行为，自动计算出这个值。   
 保存的寄存器(Saved registers)：   
 - 为调用方保存寄存器（见图6-4）所使用的字节数。IDA认为保存的寄存器区域放在保存的返回地址顶部、与函数有关的所有局部变量的下方。一些编译器选择将寄存器保存在函数局部变量的顶部。IDA认为保存这些寄存器所使用的空间属于局部变量区域，而非保存的寄存器区域。   
 已删除字节(Purged bytes)：   
 - 已删除字节表示当函数返回调用方时，IDA从栈中删除的参数的字节数。对cdecl函数而言，这个值始终为0。对stdcall函数来说，这个值表示传递到栈上的所有参数占用的空间。在x86程序中，如果IDA观察到程序使用了返回指令的RET N变体，它将自动确定这个值。   
 帧指针增量(Frame pointer delta):   
 - 有时候，编译器可能会对函数的帧指针进行调整，使其指向局部变量区域的中间，而不是指向保存在局部变量区域底部的帧指针。调整后的帧指针到保存的帧指针之间的这段距离叫做帧指针增量。

 属性：   
 不返回(Does not return)：   
 - 函数不返回到它的调用方。如果调用这样的函数，在相关的调用指令之后，IDA认为函数不会继续执行  
 库函数(Library func)：   
 - 这个属性将一个函数标记为库代码   
 基于BP的帧(BP based frame)：   
 - 这个特性表示函数利用了一个帧指针。多数情况下，你可以通过分析函数的“序言”来自动确定这一点。但是，如果通过分析无法确定给定的函数是否使用了帧指针，就可以手动选择这个特性。如果你手动选择了这个特性，一定要相应地调整保存的寄存器的大小（通常指根据保存的帧指针的大小增大）和局部变量的大小（通常指根据保存的帧指针的大小减少）。对基于帧指针的帧而言，使用帧指针的内存引用被格式化，以利用符号栈变量名称，而非数字偏移量。如果没有设置这个特性，则认为栈帧引用与栈指针寄存器有关。   
 BP等于SP(BP equals to SP)：   
 - 一些函数将帧指针配置为在进入一个函数时指向栈帧（以及栈指针）的顶端。在这种情况下，就应设置该属性。基本上，它的作用等同于将帧指针增量的大小设置为等于局部变量区域

   
 