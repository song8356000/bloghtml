---
title: 程序输入表修复
date: 2015-12-07 18:38:55
tags: CSDN迁移
---
 版权声明：需要转载的请注明出处 https://blog.csdn.net/qq_22642239/article/details/50209427   
   1.使用的一款修复输入表的工具：Import REConstructor,如下图所示： 

 

 ![](https://img-blog.csdn.net/20151207183837852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 

 2.一个加过壳的程序在经过脱壳后，输入表一般会出现问题，出现各种程序不能运行的情况，这时就需要修复输入表。

 打开未脱壳的程序（因为该修复输入表的工具需要附加到一个活动的进程），然后将打开的未脱壳的程序加载到该工具中，

 然后OEP处输入未脱壳程序的OEP（程序的原始入口点），

 OEP一般在经过OD调试脱壳后就可以得到，如上图该实验程序的OEP为271B0（该位置填的是程序原始入口点的偏移地址而不是基址，因为该调试工具会自动定位程序的基址），

 然后点击自动查找IAT按钮，该工具会自动寻找到未脱壳程序的输入表的RVA：60814（相对偏移地址）和大小718如上图所示，

 需要注意的是这些数据都是16进制数（0X），

 走到这里就需要手动的查一下OD里面的调试过程，在OD里面数据区域搜索一下460814这个区域的数据情况，一般情况下你可以看到许多API函数，或者是一些乱码（我感觉是某种加密就像 ASCII码或者UNICODE码那样无法识别出来，所以显示的是乱码）

 输入表区域一般是一个完整的的区域，一般在这个区域只要不是“...............”这些东西（说的有点俗）一整块的数据基本都属于输入表的内容，所以一般从这个完整的数据块的首地址开始算起到这个数据块结束的地址的大小为这个数据块的大小（也就是需要填写到上图“大小”位置处的数据），对于这个大小，个人感觉一般能大不能小，某些特殊的程序除外。

 在这里我感觉还有一种情况需要注意就是有时候在这一整块数据区域有一小部分数据并不需要，或者说是干扰，你如果加进去的话修复过的程序还是无法打开，对于这种情况我个人的看法是遵照该修复工具自动查找得到的RVA和大小，在修改某个程序的输入表时可以尝试一下哪种方式可以成功，毕竟我的水平有限，深层次的知识还不了解，有待进一步提高。

 经过这些过程以后就可以点击获取输入表按钮，然后你可以看到程序飞快的加载了好多输入表的函数（这里都是函数的指针及函数的数字），加载完成后，可以点击“显示无效的”按钮，如果输入的IAT大小较大，估计会稍等一会该工具才会显示出来，显示出来以后（那些蓝色的家伙）直接右键（不要手残的去点左键。。。）点击“剪切指针”按钮，这个过程该工具应该会小卡一下，但这是正常情况，你可以发现他正在进行某种操作，CPU都占用了好多。。。 ，等剪切完成，接着点击“修复转储文件”按钮然后选择你用OD DUMP出来的那个不能正常打开的脱壳程序，然后该工具会自动为你创建一个新的程序，这就是修复过后的程序，到这里，一个程序的输入表的修复工作完成。然后你就可以点击运行了，ok... 关于更深层次的东西以后继续深入

   
 