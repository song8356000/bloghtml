---
title: MFC字符串操作（二）CString.Format的用法
date: 2018-09-17 14:53:44
tags: CSDN迁移
---
   在MFC程序中，使用CString来处理字符串是一个很不错的选择。CString既可以处理Unicode标准的字符串，也可以处理ANSI标准的字符串（注：此处的Unicode标准和ANSI标准都是字符编码的一种方式，后续会做总结）。CString的Format方法给我们进行字符串的转换带来了很大的方便，比如常见的int、float和double这些数字类型转换为CString字符串只需一行代码就可以实现。 

 先看看Format用于转换的格式字符：

 %c 单个字符

 %d 十进制整数(int)

 %ld 十进制整数(long)

 %f 十进制浮点数(float)

 %lf 十进制浮点数(double)

 %o 八进制数

 %s 字符串

 %u 无符号十进制数

 %x 十六进制数

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 int转换为CString：

 CString str;

 int number=15;

 str.Format(_T("%d"),number);

 //结果str="15"

 

 str.Format(_T("%4d"),number);

 //结果 str=" 15"(前面有两个空格；4表示将占用4位，如果数字超过4位将输出所有数字，不会截断)

 

 str.Format(_T("%.4d"),number);

 //结果 str="0015"(.4表示将占用4位，如果数字超过4位将输出所有数字，不会截断) 

 long转换为CString的方法与上面相似，只需要把%d改为%ld就可以了。

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 double转换为CString：

 CString str;

 double num=1.46;

 str.Format(_T("%lf"),num);

 //结果str="1.46"

 

 str.Format(_T("%.1lf"),num);

 //结果str="1.5"(.1表示小数点后留1位，小数点后超过1位则四舍五入)

 

 str.Format(_T("%.4f"),num);

 //结果str="1.4600"

 

 str.Format(_T("%7.4f"),num);

 //结果str=" 1.4600"(前面有1个空格)

 

 float转换为CString的方法也同上面相似，将lf%改为f%就可以了。

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 十进制数转换为八进制：

 CString str;

 int num=255;

 str.Format(_T("%o"),num);

 //结果 str="377"

 

 str.Format(_T("%.8o"),num);

 //结果str="00000377"

 

 十进制数转换为十六进制的方法也同上面相似，将o%改为x%就可以了。

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Format是一个很常用，却又似乎很烦的方法，以下是它的完整概貌，以供大家查询之用： 

 格式说明总是以%字符开始,以下是不同类型数据的格式方式%号后的说明:   
 d输出带符号十进制数   
 o输出无符号八进制数   
 x输出无符号十六进制数   
 u输出无符号数   
 c输出单个字符   
 s输出一串字符   
 f输出实数（6位小数）   
 e以指数形式输出实数   
 g选用f与e格式中输出宽度较小的格式，不输出0   
 ld输入输出long型数据   
 lf输入输出double型数据   
 m数据输出宽度为m   
 .n输出小数位数为n 

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 字符串

 Format("my name is %6s","wind");   
 返回后就是   
 my name is wind   
  
 现在来看Format参数的详细情况：   
 Format里面可以写普通的字符串，比如"my name is"   
 但有些格式指令字符具有特殊意义，比如"%6s" 

 格式指令具有以下的形式：   
 "%" [index ":"] ["-"] [width] ["." prec] type   
 它是以"%"开始,而以type结束，type表示一个具体的类型。中间是用来   
 格式化type类型的指令字符，是可选的。 

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 type

 先来看看type,type可以是以下字符：   
 d 十制数，表示一个整型值 

 u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时   
 是一个2的32次方减去这个绝对值的数   
 如：Format("this is %u",-2);   
 返回的是：this is 4294967294 

 

 f 对应浮点数 

 e 科学表示法，对应整型数和浮点数，   
 比如Format("this is %e",-2.22);   
 返回的是：this is -2.220000E+000   
 等一下再说明如果将数的精度缩小 

 g 这个只能对应浮点型，且它会将值中多余的数去掉   
 比如Format("this is %g",02.200);   
 返回的是：this is 2.2 

 n 只能对应浮点型，将值转化为号码的形式。看一个例子就明白了   
 Format("this is %n",4552.2176);   
 返回的是this is 4,552.22   
 注意有两点:一是只表示到小数后两位，等一下说怎么消除这种情况；   
 二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 

 m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化   
 另外它只对应于浮点值   
 Format("this is %m",9552.21);   
 返回：this is ￥9,552.21 

 p 对应于指针类型，返回的值是指针的地址，以十六进制的形式来表示   
 例如：   
 Format("this is %p",p);   
 Edit1的内容是：this is 0012F548 

 s 对应字符串类型，不用多说了吧 

 x 必须是一个整形值，以十六进制的形式返回   
 Format("this is %X",15);   
 返回是：this is F   
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
 类型讲述完毕，下面介绍格式化Type的指令：   
 [index ":"] 看一个例子   
 Format("this is %d %d",12,13);   
 其中第一个%d的索引是0，第二个%d是1，所以字符显示的时候   
 是这样 this is 12 13   
 而如果你这样定义：   
 Format("this is %1:d %0:d",12,13);   
 那么返回的字符串就变成了   
 this is 13 12   
 现在明白了吗，[index ":"] 中的index指示Args中参数显示的   
 顺序   
 还有一种情况，如果这样Format("%d %d %d %0:d %d", 1, 2, 3, 4) ;   
 将返回1 2 3 1 2  
 如果你想返回的是1 2 3 1 4，必须这样定：   
 Format("%d %d %d %0:d %3:d", 1, 2, 3, 4) ;   
 但用的时候要注意，索引不能超出Args中的个数，不然会引起异常   
 如Format("this is %2:d %0:d",12,13); //error  
 由于Args中只有12 13 两个数，所以Index只能是0或1，这里为2就错了 

 [width] 指定将被格式化的值占的宽度，看一个例子就明白了   
 Format("this is %4d",12);   
 输出是：this is 12   
 这个是比较容易，不过如果Width的值小于参数的长度，则没有效果。   
 如：Format("this is %1d",12);   
 输出是：this is 12 

 ["-"] 这个指定参数向左齐，和[width]合在一起最可以看到效果：   
 Format("this is %-4d,yes",12);   
 输出是：this is 12 ,yes   
  
 ["." prec] 指定精度，对于浮点数效果最佳：   
 Format('this is %.2f',['1.1234]);   
 输出 this is 1.12   
 Format('this is %.7f',['1.1234]);   
 输了 this is 1.1234000   
  
 而对于整型数，如果prec比如整型的位数小，则没有效果   
 反之比整形值的位数大，则会在整型值的前面以0补之   
 Format('this is %.7d',[1234]);   
 输出是：this is 0001234]   
  
 对于字符型，刚好和整型值相反，如果prec比字符串型的长度大   
 则没有效果，反之比字符串型的长度小，则会截断尾部的字符   
 Format('this is %.2s',['1234']);   
 输出是 this is 12   
  
 而上面说的这个例子：   
 Format('this is %e',[-2.22]);   
 返回的是：this is -2.22000000000000E+000   
 怎么去掉多余的0呢，这个就行啦   
 Format('this is %.2e',[-2.22]);

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 sprintf:

 与之对应的另一种格式化字符串输出方式是使用 sprintf: 

 虽然说CString类有着许多的优点，但是并不能包办所有的操作，最直接的一个问题就是

 CString并不能直接赋值给一个字符串变量，即CString类并没有提供一种调用，可以将其内部的字符串赋值给一个字符串变量，如果要进行这种操作，则必须手动编程完成，但是某些函数中又必须要用到字符串数组类型，这个时候又面临一个问题，即字符串数组该怎样来格式化，这个时候需要调用sprintf函数，该函数是个全局函数，其调用的格式如下： 

 sprintf( buffer, " String: %s\n", s ); 

 该函数中，buffer是需要被格式化的字符串数组，而“”中的内容就是格式化内容，最后的则是各种数字或这字符串等，该函数很方便使用目前用到的格式化字符串操作。

 举个使用sprintf格式化输出字符串的例子：

 CString m_csFileName=PROGRAM_PATH+_T("\\audio");//strVoiceFilePath 

 wchar_t s[30] = {0};

 _stprintf(s,_T("%d%d%d%d%d%d"),sys2.wYear,sys2.wMonth,sys2.wDay,sys2.wHour,sys2.wMinute,sys2.wSecond/*,sys2.wMilliseconds*/);

 m_csFileName.Append(s);

 m_csFileName.Append(_T(".wav"));

 注意：1.PROGRAM_PATH是一个CString类型，表示的是系统当前的绝对路径

 2.CString的成员函数Append 用到了字符串的拼接

 

 最后，用以上两种思路都可以基本上解决，在使用注意UNICODE就行了，如果用到了UNICODE码，注意用_T()来进行转换

   
 