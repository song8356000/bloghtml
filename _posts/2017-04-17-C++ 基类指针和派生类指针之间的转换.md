---
title: C++ 基类指针和派生类指针之间的转换
date: 2019-04-28 17:39:12
tags: CSDN迁移
---
   **函数重载、函数隐藏、函数覆盖**  
**函数重载只会发生在同作用域中（或同一个类中）**，函数名称相同，但参数类型或参数个数不同。 函数重载不能通过函数的返回类型来区分，因为在函数返回之前我们并不知道函数的返回类型。

 **函数隐藏和函数覆盖只会发生在基类和派生类之间。**

 **函数隐藏是指派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，这种情况就是函数的隐藏。**  
 所谓隐藏是指使用常规的调用方法，派生类对象访问这个函数时，会优先访问派生类中的这个函数，基类中的这个函数对派生类对象来说是隐藏起来的。 但是隐藏并不意味这不存在或完全不可访问。通过 b->Base::func()访问基类中被隐藏的函数。

 **函数覆盖特指由基类中定义的虚函数引发的一种多态现象。**在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。

 **函数覆盖的条件：**

 1： 基类中的成员函数被virtual关键字声明为虚函数;  
 2：派生类中该函数必须和基类中函数的名称、参数类型和个数等完全一致;  
 3：将派生类的对象赋给基类指针或者引用，实现多态。  
 函数覆盖（多态）实现了一种基类访问（不同）派生类的方法。我们把它称为基类的逆袭。

 

 **基类指针和派生类指针之间的转换**  
**1. 基类指针指向基类对象、派生类指针指向派生类对象**  
 这种情况是常用的，只需要通过对应类的指针直接调用对应类的功能就可以了。

 
```
 #include<iostream>
using namespace std;
 
class Father{
public:    
    void print()
    {
        printf("Father's function!");
    }
};
 
class Son:public Father
{
public:
    void print()
    {
        printf("Son's function!");
    }
};
 
int main()
{
    Father f1;
    Son s1;
 
    Father* f = &f1;
    Son* s = &s1;
 
    f->print();
    cout<<endl<<endl;
    s->print();
}

```
 **2. 基类指针指向派生类对象**

 这种情况是允许的，通过定义一个基类指针和一个派生类对象，把基类指针指向派生类对象，但是需要注意，通常情况这时的指针调用的是基类的成员函数。分四种情况：

 **一、 函数在基类和派生类中都存在**

 这时通过“指向派生类对象的基类指针”调用成员函数，调用的是基类的成员函数。 

 
```
   Father f1;
    Son s1;

    Father* f = &s1;
    f->print();  //调用的是基类成员函数
```
 ** 二、函数在基类中不存在，在派生类中存在**

 由于调用的还是基类中的成员函数，试图通过基类指针调用派生类才有的成员函数，则编译器会报错。

 error C2039: “xxx”: 不是“Father”的成员

 ** 三、 将基类指针强制转换为派生类指针**

 这种是向下的强制类型转换，转换之后“指向派生类的基类指针”就可以访问派生类的成员函数：

 

 
```
  Son s1;
    Father* f = &s1;
    Son *s = (Son*)f;
    s->print1(); //调用派生类成员函数
```
 但是这种强制转换操作是一种潜在的危险操作。

 ** 四、基类中存在虚函数的情况**

 如果基类中的成员函数被定义为虚函数，并且在派生类中也实现了该函数，则通过“指向派生类的基类指针” 访问虚函数，访问的是派生类中的实现。允许“基类指针指向派生类”这个操作，最大的意义也就在此，通过虚函数和函数覆盖，实现了“多态”（指向不同的派生类，实现不同功能）。 

 
```
 Father f1;
    Son s1;

    Father* f = &s1;
    f->print();   //调用派生类成员函数


```
 **3. 派生类指针指向基类对象**

 会产生编译错误。基类对象无法被当作派生类对象，派生类中可能具有只有派生类才有的成员或成员函数。  
 即便是使用强制转换，将派生类指针强制转换成基类指针，通过这个“强制指向基类的派生类指针”访问的函数依然是派生类的成员函数。 

 
```
 Father f1;
    Son s1;

    Son* s=&s1;
    Father* f = (Father*) s;

    f->print();  //调用派生类成员函数
```
 综上，可以通过基类指针访问派生类方法（强制转换和虚函数），不存在通过派生类指针调用基类成员函数的方法（即便是强制转换）。

 感谢原作者的分享！  
 原文地址：https://blog.csdn.net/dcrmg/article/details/83472660   
 

   
 